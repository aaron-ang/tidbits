(0.0):  So at this point, we're pretty familiar with all of the data types (2.799999952316284):  that come native to C. We have characters, and floats, and integers, (6.840000152587891):  and doubles. (8.119999885559082):  And we're also familiar now with the CS50 data types of strings and bools. (13.279999732971191):  But that doesn't limit everything that we can do. (15.5600004196167):  We surely can do more. (17.200000762939453):  Indeed, with structures, that gives us an ability (19.200000762939453):  to start to define our own data types that (21.040000915527344):  might be useful for our own programs. (23.520000457763672):  What's cool about structures is they allow (25.239999771118164):  us to unify many different variables of different data types (29.15999984741211):  into a single brand new type. (31.799999237060547):  And we can give that new type its own unique type name (34.84000015258789):  as a way to identify it. (36.439998626708984):  This isn't the first time we've seen the ability to combine (39.040000915527344):  multiple variables together. (40.720001220703125):  We've seen that with arrays. (41.959999084472656):  Remember, the restriction with arrays is that we can only (43.68000030517578):  combine things of the same type. (45.040000915527344):  We can have a whole bunch of integers or a whole bunch of floats, (47.91999816894531):  but we can't mix them up. (49.91999816894531):  With structures, we actually can. (51.880001068115234):  We can group together logical elements that (54.31999969482422):  have a logical connection to one another. (56.0):  So for example, we can group together a structure for, say, a student, (60.20000076293945):  where a student would have an ID number, which is probably an integer. (63.15999984741211):  They also have a name, which is a string. (65.23999786376953):  And they might have a GPA, which is a float. (67.55999755859375):  And we can have all of these things tied together. (69.91999816894531):  And basically, it's a super variable. (71.83999633789062):  It's a variable that has other variables within it. (76.0):  The way to do this in C is actually pretty straightforward. (78.55999755859375):  Some syntax might look like this. (79.95999908447266):  Instead of a student in this example, let's use a car. (83.23999786376953):  We introduce the concept of a structure by saying struct. (86.63999938964844):  We're about to define a structure type. (88.91999816894531):  And in particular, we're going to define a struct car. (92.19999694824219):  And struct car actually now becomes our type name. (95.36000061035156):  It's not just car. (96.68000030517578):  It's struct car. (98.5199966430664):  Inside of the curly braces from this point forward, (100.76000213623047):  we can define all of the different variables (102.87999725341797):  that we want inside of our super variable. (105.19999694824219):  So for example, here are some things that are common to cars. (108.0):  They have a year, the year that they were manufactured. (111.08000183105469):  We have a model, and a license plate, and an odometer, (115.68000030517578):  which is a number of miles. (116.83999633789062):  And maybe they have an engine size, which in the United States (119.5199966430664):  is usually represented as a float for how many liters the engine capacity is. (124.44000244140625):  And notice that these are all different data types being mixed together. (127.4000015258789):  We have integers, and we have two strings, (129.24000549316406):  and we have a float, or a double, all mixed up inside of one super variable. (133.8000030517578):  To finish our definition of the structure, (135.55999755859375):  we have a closing curly brace. (136.83999633789062):  And then really important, a common syntax error (139.1199951171875):  is a semicolon at the end, which completes our definition of a struct car. (145.0):  Once we define the structure, and usually we (146.83999633789062):  define our structure at the very top of our program, (149.0399932861328):  up near our pound includes and our pound defines, (151.9600067138672):  we also might define them in a separate .h file, (154.67999267578125):  because maybe we're using this type definition in several different files, (159.4199981689453):  or several different programs. (160.72000122070312):  And so it makes sense to define it somewhere outside of a single file (165.8000030517578):  and have it be a .h file that we can pound include (168.0800018310547):  in multiple different contexts. (170.0399932861328):  Now we have effectively created this new type, and we can start to use it. (173.9600067138672):  And we can create variables of this type just (176.32000732421875):  like we can create variables of any other type. (178.27999877929688):  Int x, that's how we create an integer called x. (180.9199981689453):  Struct car y, that's how we create a variable called y of type struct car. (186.16000366210938):  So that's how we create the variable overall. (188.9199981689453):  How do we create the individual fields or members of that? (192.75999450683594):  Rather, how do we access the individual fields or members of that structure? (195.8800048828125):  We can do so using something called the dot operator. (199.1199951171875):  Let's take a look at what that looks like. (200.9199981689453):  So at the top here, I have a variable declaration, struct car my car. (204.9199981689453):  Again, here the type is struct car, and the variable name is my car. (211.39999389648438):  From this point forward, whenever I want to refer to a field or a member (216.27999877929688):  within my car, which is, again, the variable name, (218.8000030517578):  I can use the dot operator to access those individual fields (222.1999969482422):  within my car. (223.36000061035156):  So I could say, for example, my car dot year equals 2011. (226.9600067138672):  I can't just say year equals 2011. (229.24000549316406):  Year is something that is part of my car, (232.44000244140625):  so I have to always refer to it in the context of my car. (235.72000122070312):  I can say str copy my car dot plate CS50. (239.83999633789062):  Remember, it's a string. (241.0399932861328):  I can't just assign it. (242.63999938964844):  I have to copy that string into the variable. (246.75999450683594):  I can say my car dot odometer equals 50505 or anything else that I want to do. (251.1999969482422):  I can set the engine size, and I can set the model. (254.63999938964844):  I can do whatever else I want to do just by accessing (257.9599914550781):  the fields similar to this. (261.32000732421875):  But structures, like variables of all other data types, (263.6000061035156):  we don't have to just use the stack for this. (265.6000061035156):  We don't just have to say struct car my car semicolon. (269.44000244140625):  We could dynamically allocate this. (271.0400085449219):  If we don't know at the beginning of our program, for example, (273.0400085449219):  that we're going to need a certain number of these things, (276.0):  we can just declare this on the fly dynamically using pointers, of course. (281.55999755859375):  In order to access our fields in that situation, (283.6400146484375):  we don't use just the dot operator because we have a pointer to a structure. (287.3599853515625):  We also have to first, as you may recall, dereference that pointer (291.0):  and then access its fields. (292.6400146484375):  It adds a little bit of extra stuff, but let's take a look again here. (296.0799865722656):  So here now, instead of statically declaring a struct car called my car, (300.6400146484375):  I'm going to dynamically allocate a struct car called my car. (304.3599853515625):  So struct car star my car, and then I'm going to malloc space for a struct car. (310.3999938964844):  And here's a cool thing about sizeof. (312.20001220703125):  Sizeof is not just built in. (313.8800048828125):  It doesn't just happen to know just the size of integers, characters, floats, (317.3999938964844):  and doubles. (318.0799865722656):  It can also figure out on the fly exactly how much space (320.8800048828125):  is required for a struct car. (322.2799987792969):  So you don't have to go through and figure out, (324.239990234375):  OK, well, this is probably like 30 bytes or something. (326.5199890136719):  You can just say sizeof struct car and let the computer figure it out for you. (330.239990234375):  So struct car star my car equals malloc sizeof struct car. (334.0799865722656):  That dynamically allocates on the heap one chunk of memory (339.1600036621094):  large enough to hold a single struct car within it. (342.6000061035156):  And then I can access my fields by first dereferencing the pointer. (347.6400146484375):  And then once I've dereferenced the pointer, (349.44000244140625):  I can then use the dot operator to access the fields. (352.8399963378906):  Again, it's very similar to what we just saw, (354.6400146484375):  but the syntax here is a little cumbersome. (356.32000732421875):  Right now, we have extra parentheses. (357.8800048828125):  We have this star. (358.67999267578125):  We have this dot. (359.44000244140625):  Surely, there's got to be an easier way. (361.44000244140625):  C programmers love for there to be easier ways to do things. (364.0):  And in fact, there is a shortcut for this. (367.67999267578125):  It so happens that accessing the field of a structure via its pointer (372.3599853515625):  is a common enough operation that there is an entirely different operator that (376.3999938964844):  allows us to do this much more succinctly. (379.0400085449219):  And it's called the arrow operator, which is just a hyphen and then (381.760009765625):  a greater than symbol, literally making it look like it's an arrow. (385.9599914550781):  It does two operations back to back. (389.1600036621094):  So the first thing it does is it dereferences (391.3599853515625):  the pointer, which is on the left of the arrow. (394.3999938964844):  And then it's going to access the field, which is on the right of the arrow. (398.0400085449219):  So for example, this is what the code looked like before. (401.32000732421875):  This is what we just had on the slide a second ago, where (403.6400146484375):  I'm dereferencing pointers. (405.44000244140625):  And then I'm using the dot operator to access the fields. (409.1199951171875):  Here is what the same code would look like with the arrow syntax. (411.9200134277344):  And the same thing is happening here. (413.4800109863281):  The first thing I'm doing is I'm dereferencing my car. (416.2799987792969):  But the arrow operator does that for me. (417.9599914550781):  I don't have to use the star syntax. (419.44000244140625):  It just knows if I have an arrow there, I (421.79998779296875):  need to first dereference the thing on the left, (424.5199890136719):  and then I can access the field on the right. (427.32000732421875):  So using the arrow operator is a great way to have a shorthand (430.44000244140625):  for accessing the field of a structure to which you only have a pointer. (434.6000061035156):  And you'll probably use this a fair amount. (436.8399963378906):  So it's syntax definitely to befriend and to get used to. (441.5199890136719):  I'm Doug Lloyd. (442.3999938964844):  This is CS50. 