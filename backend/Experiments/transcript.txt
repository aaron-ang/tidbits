(60.0):  All right, this is CS50, and this is week five. (67.44000244140625):  And among our goals for today are to revisit some topics from past weeks, (71.5199966430664):  but to focus all the more on design possibilities, (75.12000274658203):  particularly by way of data structures. (77.0):  So data structures, again, is this way via which you can structure your data. (80.76000213623047):  But more specifically in C, it's like how you can use your computer's memory (84.68000030517578):  in interesting and, dare say, clever ways to actually solve problems (87.95999908447266):  more effectively. (88.87999725341797):  But we're going to see today that there's actually (90.95999908447266):  different types of data structures. (93.08000183105469):  And we'll make the distinction between abstractions, (95.5199966430664):  like high-level descriptions of these structures, (97.91999816894531):  and the lower-level implementation details, so to speak. (100.80000305175781):  So in particular, we'll talk first today about what we call abstract data type. (104.72000122070312):  So an abstract data type is kind of like a data structure, (107.91999816894531):  but it offers certain properties, certain characteristics. (110.91999816894531):  And it's actually up to the programmer how (112.76000213623047):  to implement the underlying implementation details. (115.4000015258789):  So for instance, there's actually this abstract data type (118.87999725341797):  that's common in computing known as a queue. (121.0):  And from the real world, most of us are presumably familiar with queues, (124.55999755859375):  otherwise known in the US typically as lines or forming lines. (127.77999877929688):  In fact, I have here three bags of cookies. (132.0800018310547):  Could I get three volunteers to come up on stage and queue up? (134.72000122070312):  OK, I saw your hand first. (136.36000061035156):  How about your hand second? (137.63999938964844):  And in the blue, in the blue? (140.0):  OK, come on down. (141.0399932861328):  Just you three. (142.83999633789062):  Come on over. (143.55999755859375):  And if you want to queue up over here, if you could. (149.16000366210938):  Come on down. (150.0399932861328):  Thank you. (150.55999755859375):  As we begin, do you want to introduce yourselves first? (152.9600067138672):  Hi, my name is Aftali Arowitz. (154.67999267578125):  I'm a first year studying computer science and economics. (157.9600067138672):  And I sleep at Robot Hall. (161.67999267578125):  All right, next. (162.75999450683594):  Hi, everyone. (163.39999389648438):  My name is Catherine. (164.60000610351562):  I'm planning on studying engineering. (166.24000549316406):  Not sure mechanical or electrical yet, but one of the two. (169.0399932861328):  And I'm currently in Kennedy. (170.47999572753906):  Nice, nice to meet. (171.9199981689453):  Hi, everyone. (172.63999938964844):  I'm Isabella. (173.67999267578125):  I'm in Strauss. (174.63999938964844):  And I plan on majoring in computer science. (176.83999633789062):  Wonderful. (177.32000732421875):  Well, welcome to all three of you. (178.9199981689453):  And I think this will be pretty straightforward. (180.52000427246094):  I have here these three bags of cookies. (182.39999389648438):  You formed nicely this line or this queue. (184.67999267578125):  So if you'd like to come up first and take your cookies. (187.16000366210938):  Thank you. (187.60000610351562):  And right that way. (188.39999389648438):  That's all there is to this demonstration. (190.1999969482422):  Your cookies as well. (191.47999572753906):  Right this way. (192.83999633789062):  And your cookies. (193.55999755859375):  Right this way. (194.27999877929688):  Wonderfully well done. (195.60000610351562):  Thank you to our volunteers. (197.32000732421875):  The point is actually sincere, though. (199.60000610351562):  Simple as that demonstration was, and as easy as it was to get those cookies, (203.55999755859375):  queues actually manifest a property that actually (206.67999267578125):  is germane to a lot of problem solving and computing in the real world. (209.8800048828125):  Specifically, queues offer this characteristic. (212.67999267578125):  FIFO. (213.27999877929688):  First in, first out. (215.1999969482422):  And indeed, as our volunteers just noticed as they queued up on stage one, (219.0399932861328):  two, three, that is the order in which I handed them their cookies. (222.44000244140625):  I dare say it's a very equitable approach. (224.32000732421875):  It's very fair. (225.0399932861328):  First come, first served might be a more casual way of describing FIFO. (228.9199981689453):  First in, first out. (230.55999755859375):  Now, structures like these actually offer specific operations (233.55999755859375):  that make sense. (234.24000549316406):  And in the context of queues, we generally (236.0399932861328):  describe these operations as enqueuing and dequeuing. (238.8800048828125):  So when our first three volunteers came up, they enqueued. (241.72000122070312):  And as I handed them each a bag of cookies, (244.0800018310547):  they dequeued and exited in that same order. (246.72000122070312):  Now, how could you go about implementing a queue in code, specifically in C? (251.72000122070312):  Well, we can actually implement it in bunches of different ways. (254.36000061035156):  But perhaps the most obvious is to borrow our old friend, namely, arrays. (258.20001220703125):  And we could use a data structure that looks a little something like this, (262.0):  whereby we specify the total capacity of this data structure. (266.2799987792969):  For instance, we might store a total of 50 people, or just three in this case. (270.2799987792969):  We might define our structure, then, as containing those people (273.3599853515625):  as simply an array. (274.67999267578125):  And if a person is a data type that we've defined in weak pass, (278.0):  you can imagine each of our volunteers is indeed a person. (280.760009765625):  And we've stored them one after the other, (282.8399963378906):  continuously in memory, by way of this actual array. (287.6400146484375):  But we do need to keep track inside of a queue using one other piece of data. (291.67999267578125):  Namely, we need to keep track of an integer, (293.55999755859375):  like the size, like how many people are actually in the queue at this moment. (297.79998779296875):  Because if we have a total capacity of 50, (300.2799987792969):  I'd like to know if I only have three volunteers, (302.4800109863281):  then I can do some quick arithmetic and know (304.32000732421875):  that I could have fit another 47 people in this same queue. (308.4800109863281):  But it's finite, of course. (310.0400085449219):  If we had 50 volunteers all wanting cookies, (312.3599853515625):  that's as many people as we could actually handle. (314.7200012207031):  So there is this upper bound, then, on how many we could fit. (318.0):  But there's yet other ways for storing data inside of a computer's memory. (321.8399963378906):  And there's this other abstract data type known as a stack. (324.44000244140625):  And stacks are actually omnipresent as well, (326.7200012207031):  even though it's not necessarily the system (329.20001220703125):  you would want when you line up on stage. (331.67999267578125):  For instance, could we get three more volunteers? (334.0400085449219):  OK, I saw hands here, right here, and right here. (337.1600036621094):  Come on down. (338.239990234375):  We'll have the orchestra come up this time. (340.55999755859375):  All right, come on over. (343.8800048828125):  And if you wouldn't mind, come on over. (345.7200012207031):  We'll do introductions first. (348.0):  This will be almost as easy as the last one. (349.8800048828125):  If you want to introduce yourself. (350.8800048828125):  And let me just stack you against the lectern this time. (352.79998779296875):  So if you could go there, and if you could come over here, (355.4800109863281):  and if you could come over here, we'll stack all three of you. (358.20001220703125):  So you were first, so you're first in the stack. (360.239990234375):  Hi, I'm Seal. (361.20001220703125):  I have no idea what I'm studying, and I live in Straus. (364.0799865722656):  Wonderful, and next. (365.32000732421875):  Hi, I'm Tanai. (366.0799865722656):  I'm studying econ and CS, and I live in Canada. (369.44000244140625):  Hi, I'm Claire. (370.239990234375):  I want to study applied math, and I'm in Wigglesworth. (372.44000244140625):  Wonderful. (372.9599914550781):  Welcome to all three. (374.0):  And if I may, let me just advance a bit more information about stacks. (378.3599853515625):  The catch is that stacks actually support what's known as LIFO. (382.3999938964844):  So last in, first out, which is sort of the opposite, really, (385.79998779296875):  of a queue or a line. (386.8800048828125):  So in fact, you were last in line. (388.55999755859375):  So here we have your cookies. (390.0400085449219):  Thank you so much, if you'd like to exit that way. (392.2799987792969):  We have your cookies here. (393.3599853515625):  Thank you so much. (394.1199951171875):  We'd like you to exit this way. (395.55999755859375):  And oh, even though you were first, LIFO doesn't really give you any cookies, (400.5199890136719):  because you're first in, not last in. (403.8800048828125):  And so yeah, OK, point's made. (406.0400085449219):  We'll give you their cookies. (407.3599853515625):  All right, so thank you to all three of our volunteers. (410.1600036621094):  But LIFO, suffice it to say, doesn't offer the same fairness guarantees (416.0400085449219):  as a queue or a line more traditionally. (418.20001220703125):  And imagine just lining up in any store, or the dining hall, or the like. (421.79998779296875):  Ideally, you want the people running the place (424.79998779296875):  to adhere to that queue, to that line, so that FIFO is preserved, (428.79998779296875):  if you indeed care about being first. (430.760009765625):  Whereas there are contexts in which LIFO does actually make sense. (435.1600036621094):  In fact, if you think about Gmail, your inbox, or Outlook, (438.2799987792969):  typically you're viewing your inbox as a stack, right? (441.239990234375):  Because when you get new mail, where does it end up? (443.44000244140625):  It actually ends up on the top, on the top, and the top. (446.0):  And if you're like me, odds are, which emails do you tend to first? (450.0799865722656):  I mean, probably the ones on the top, the ones that came in last, (453.5400085449219):  most recently, that is. (455.2799987792969):  And that might actually be to the detriment (457.2799987792969):  of people who emailed you earlier today, or yesterday. (459.7200012207031):  Because once they sort of fall off the bottom of your screen, frankly, (462.6400146484375):  unless you click Next, you may never see those emails again. (465.44000244140625):  But stacks are indeed one way of storing data. (468.1600036621094):  And Google and Microsoft presumably made the judgment call (470.8399963378906):  that, in general, we users want to see the most recent data first. (475.20001220703125):  The last information might be the first we want out. (478.239990234375):  Now, just in terms of nomenclature, the two operations (481.1600036621094):  that are analogous to enqueuing and dequeuing, (484.1199951171875):  but with this property of LIFO, are instead called push and pop. (487.760009765625):  So when our first volunteer came up on stage, so to speak, (490.3999938964844):  I pushed him onto the stack against the lectern there. (493.0):  Second person was pushed. (494.3599853515625):  Third person was pushed. (495.7200012207031):  And then when it was time to hand out the cookies, (497.79998779296875):  we popped them, so to speak, one after the other, (500.5199890136719):  but preserving that LIFO property. (502.44000244140625):  But here's where things are a little interesting (504.3599853515625):  in terms of implementation details. (506.2799987792969):  A stack could be implemented almost identically underneath the hood (510.8800048828125):  to a queue. (511.9200134277344):  Because what do you need? (513.0399780273438):  You need an array of people, which we could use our person data type (516.4400024414062):  for for past classes. (518.3200073242188):  We have to keep track of how many people are in the stack (520.6799926757812):  so that even if we have a capacity of like 50, (523.3599853515625):  we know at least that we can store three plus maybe 47 others. (528.3599853515625):  Now, there's still going to be a change in the underlying implementation (531.3200073242188):  details because not pictured here is the actual C code that actually (535.280029296875):  pushes and pops or enqueues and dequeues. (538.0399780273438):  So whatever loops you're using, whatever code you're using, (541.3200073242188):  odds are that's where those properties are going to be implemented. (544.0800170898438):  FIFO versus LIFO, you're going to implement maybe the loop (546.6799926757812):  in this direction instead of this one or some such distinction. (550.5599975585938):  But at the end of the day, stacks and queues (552.6799926757812):  are just abstract data types in the sense (555.0399780273438):  that we can implement them in bunches of ways, two of them (557.7000122070312):  among them here thus far on the screen. (559.7999877929688):  But that array is going to come back to bite us. (561.8800048828125):  Because if you only have a capacity of 50, (564.47998046875):  what happens if 51 people want cookies next time? (567.4000244140625):  You just don't have room for them, even though clearly we (570.1599731445312):  have enough room for the people themselves. (572.0):  We have enough memory, and so it seems a little short-sighted (574.6400146484375):  to limit just how much data can fit in our data structures. (578.280029296875):  So with that said, a friend of ours, Shannon Duvall at Elon University, (581.5599975585938):  kindly put together a visualization of the same (585.5599975585938):  and allow me to introduce you to two fellows known as Jack and Lou, (590.52001953125):  if we could dim the lights for this video. (593.52001953125):  Once upon a time, there was a guy named Jack. (596.52001953125):  When it came to making friends, Jack did not have the knack. (600.1199951171875):  So Jack went to talk to the most popular guy he knew. (603.0399780273438):  He went up to Lou and asked, what do I do? (605.5999755859375):  Lou saw that his friend was really distressed. (608.2000122070312):  Well, Lou began, just look how you're dressed. (610.6400146484375):  Don't you have any clothes with a different look? (613.3599853515625):  Yes, said Jack. (614.239990234375):  I sure do. (615.4400024414062):  Come to my house, and I'll show them to you. (617.9199829101562):  So Jack went up to Lou and asked, what do I do? (620.9600219726562):  And I'll show them to you. (622.52001953125):  So they went off to Jack's, and Jack showed Lou the box (625.4400024414062):  where he kept all his shirts and his pants and his socks. (628.47998046875):  Lou said, I see you have all your clothes in a pile. (631.52001953125):  Why don't you wear some others once in a while? (634.0399780273438):  Jack said, well, when I remove clothes and socks, (637.2000122070312):  I wash them and put them away in the box. (639.9600219726562):  Then comes the next morning, and up I hop. (642.4400024414062):  I go to the box and get my clothes off the top. (645.5999755859375):  Lou quickly realized the problem with Jack. (648.3200073242188):  He kept clothes, CDs, and books in a stack. (651.3200073242188):  When he reached for something to read or to wear, (653.6400146484375):  he chose the top book or underwear. (656.3200073242188):  Then when he was done, he would put it right back. (658.719970703125):  Back it would go on top of the stack. (661.2000122070312):  I know the solution, said a triumphant Lou. (663.6799926757812):  You need to learn to start using a cue. (666.280029296875):  Lou took Jack's clothes and hung them in a closet. (669.0800170898438):  And when he had emptied the box, he just tossed it. (671.9199829101562):  Then he said, now Jack, at the end of the day, (674.3599853515625):  put your clothes on the left when you put them away. (677.2000122070312):  Then tomorrow morning, when you see the sunshine, (679.6799926757812):  get your clothes on the right from the end of the line. (682.6799926757812):  Don't you see, said Lou, it will be so nice. (685.5999755859375):  You'll wear everything once before you wear something twice. (689.0):  And with everything in cues in his closet and shelf, (691.8800048828125):  Jack started to feel quite sure of himself, (694.4000244140625):  all thanks to Lou and his wonderful cue. (701.1199951171875):  So the same, wonderful, thanks to Shannon. (704.3599853515625):  So you might've noticed I wear black all the time (706.5599975585938):  so we could make a similar gag about here's (708.2999877929688):  what my stack of clothes at home looks like. (710.719970703125):  Even though I might own a blue and a red sweatshirt, (712.9199829101562):  doesn't really work if you're popping everything from a stack (715.52001953125):  every time, cleaning it, replenishing the black sweaters before the red (718.760009765625):  or the blue even get popped themselves. (720.9600219726562):  But we're going to focus today not just on stacks and cues, which for us (724.1599731445312):  are really meant to motivate different ways of designing data, (728.0):  even though the implementation details might differ. (730.1599731445312):  But we're going to start focusing on solving some problems that invariably (732.7999877929688):  we'd be bumping up against anyway as we develop more and more real world (736.1599731445312):  software, not just smaller programs as in class. (738.6799926757812):  And arrays, recall, are what? (740.8800048828125):  Like, what's the key characteristic or definition (742.9199829101562):  of an array with respect to your computer's memory (745.47998046875):  and storing things in it? (746.5599975585938):  Yeah? (747.0599975585938):  AUDIENCE MEMBER 5 stores the data continuously. (749.1199951171875):  Perfect. (749.6400146484375):  So it stores the data contiguously back to back to back. (752.8400268554688):  And as we've seen thus far, when you allocate space for an array, (756.6400146484375):  you typically do it with square brackets. (758.3599853515625):  You specify a number in those brackets or maybe a constant capacity (761.7999877929688):  like I just did. (762.780029296875):  And that fixates just how much data you can actually store in there. (765.9600219726562):  We did see last week, though, that we could (768.280029296875):  start to use malloc to allocate an equivalent number of bytes. (772.239990234375):  But even that, when you call it just once, (774.2000122070312):  gives you back a specific finite number of bytes. (776.719970703125):  So you're similarly deciding in advance how much (778.7999877929688):  memory you can store in an array. (780.719970703125):  So let's consider what kinds of problems this should get us into. (783.52001953125):  So here's an array of size 3. (785.0399780273438):  And suppose for the sake of discussion, we've (786.8800048828125):  already put three numbers into it, 1, 2, and 3, literally. (790.52001953125):  Suppose now we want to add a fourth number to that array. (793.719970703125):  Well, where does it go? (795.0800170898438):  Intuitively and pictorially, you'd like to think it could go there. (798.719970703125):  But remember the context we introduced last week (801.3200073242188):  when we talked about computers' memories. (802.97998046875):  There's lots of stuff going on. (804.9600219726562):  And if you only ask the computer, the operating system, (807.6400146484375):  for room for three integers, who knows what's here and here and here, (812.7999877929688):  not to mention everywhere else on the screen. (814.7999877929688):  So if we zoom out, for instance, we might like to put the number 4 there. (818.52001953125):  But we can't if in that greater context, there's a lot more stuff going on. (822.9199829101562):  So for instance, suppose that elsewhere in my same program or function, (826.5599975585938):  I've already created a string like H-E-L-L-O comma space world backslash 0 (832.2000122070312):  just by bad luck. (833.2000122070312):  That could be allocated right next to my 1, 2, 3. (836.0399780273438):  Why? (836.760009765625):  Well, if I ask the operating system for space for three numbers, (839.9600219726562):  then I ask the operating system for space for a string, (842.8400268554688):  it's pretty reasonable for the computer to put those things back to back. (846.5999755859375):  Because it's not going to anticipate for us that, well, maybe they actually (850.0399780273438):  want four numbers eventually or five numbers or more. (853.1599731445312):  Now, as for all of these Oscars the grouch, (855.5599975585938):  that's just meant to represent pictorially here (858.1199951171875):  the notion of garbage values. (859.4000244140625):  Like, there's clearly other bytes there and available. (862.4400024414062):  I don't know what it is, and I don't care what it is. (864.9600219726562):  But I do care that I can't just presume to put something right (868.8800048828125):  where I want in the computer's memory unless I preemptively (871.6799926757812):  ask it for more memory. (873.4000244140625):  Now, if all of those are garbage values, which (875.3599853515625):  is to say that who cares what they are, it's (877.3599853515625):  just junk left over from previous runs of the function or the like, (881.1199951171875):  there's clearly plenty of room for a fourth number. (884.280029296875):  I could put the number 4 here or here or here or down here or here or here. (889.0399780273438):  But why would I not want to just plop the 4 wherever (891.7999877929688):  there is a garbage value currently? (894.1599731445312):  Yeah? (894.6599731445312):  AUDIENCE MEMBER 2 Because you want it to be next to your array of 1, 2, 3. (897.6799926757812):  Exactly. (898.1799926757812):  I want it to be next to my array of 1, 2, 3. (900.0800170898438):  Because, again, arrays must be and must remain contiguous. (904.0):  Now, that's not a deal breaker, right? (905.8599853515625):  Because where else could I put maybe the entire array? (909.1799926757812):  Well, there's room up here for four numbers. (911.1799926757812):  There's room down here for four numbers. (913.0999755859375):  So that's fine. (913.8200073242188):  And that could be a solution to the problem. (915.7000122070312):  If you've run out of space in your fixed size array, (918.4199829101562):  well, maybe I just abstract everything else away. (921.1400146484375):  And I just move my array to a different location that's a little bit bigger. (925.219970703125):  But there is going to be a downside, even though this is a solution, (928.02001953125):  even though I can certainly copy the 1, the 2, the 3. (931.1400146484375):  And now I can plop the 4 there. (932.739990234375):  And heck, I can then let go of the old memory in some way (936.02001953125):  and give it back to the operating system to be reused later. (939.1799926757812):  This is successful. (940.9400024414062):  But why, intuitively, might we not want this (944.3400268554688):  to be our solution of creating a new array that's a little bigger, (948.6199951171875):  copying the old into the new, and getting rid of the old? (951.4199829101562):  AUDIENCE MEMBER 2 If you want to make it bigger, (953.3400268554688):  you just have to put 16 plus and then again. (955.4600219726562):  Good, yeah. (955.9600219726562):  I think I had one more step. (957.1799926757812):  Suppose I want to add a fifth number, a sixth number. (959.5399780273438):  That's a lot of work. (960.8599853515625):  And in fact, what's the expensive part? (962.5800170898438):  Or what's the slow part of that story? (964.219970703125):  Yeah? (964.719970703125):  AUDIENCE MEMBER 3 It takes a lot of time. (966.4199829101562):  It takes a lot of time. (967.3400268554688):  But specifically, what's taking time, if we can put our finger on it? (970.6599731445312):  Yeah, in back. (971.219970703125):  AUDIENCE MEMBER 4 Do you like using twice as much memory? (974.4199829101562):  OK, for a period of time, I'm using twice as much memory, (977.760009765625):  which certainly seems wasteful. (979.2999877929688):  Because even though I don't eventually need it, (981.260009765625):  it is going to kind of mushroom and then shrink back down, (983.780029296875):  which seems like an inefficient use of resources. (986.260009765625):  But what specifically is slow about this process, too? (989.1400146484375):  Yeah, in middle. (989.780029296875):  AUDIENCE MEMBER 5 You're iterating the original array and copying it over. (993.0999755859375):  Yeah, good choice of words. (994.219970703125):  You're iterating over the array to copy it over using a for loop, a while loop. (998.4600219726562):  So it's probably like big O of n steps just to copy the array. (1001.9000244140625):  And technically, big O of n plus 1 if we add one more. (1004.3800048828125):  But that's still big O of n. (1005.6199951171875):  So it's the copying, the moving of the data, so to speak, (1008.780029296875):  that's certainly correct. (1010.1400146484375):  But maybe it's not the best design. (1012.5399780273438):  Wouldn't it be better if we could do something otherwise? (1015.260009765625):  Well, let's consider what this might actually translate into in code (1018.5800170898438):  and what the implications then might be. (1020.5):  Let me switch over here to VS Code. (1022.5399780273438):  Let me propose to open up a file called list.c, brand new. (1027.780029296875):  And just let's create this list of numbers (1029.6600341796875):  and then add to it over time and see when and where we actually (1032.3800048828125):  bump up against these problems. (1033.780029296875):  So let me include standard io.h in order to simply be (1037.699951171875):  able to print things out ultimately. (1040.02001953125):  Int main void, so no need for command line arguments here. (1043.06005859375):  Let me give myself an array called list, but just of size 3 (1047.97998046875):  for consistency with the picture thus far. (1050.1400146484375):  And now let me go ahead and just manually make (1052.219970703125):  it look like in memory what it did on the screen. (1054.260009765625):  So list bracket 0 is going to equal the number 1. (1057.6199951171875):  List bracket 1 is going to equal the number 2. (1060.800048828125):  And list bracket 2 equals the number 3. (1062.93994140625):  So even though the array is, of course, 0 indexed, (1065.3800048828125):  I'm just sort of using more familiar 1, 2, 3 as my digits here. (1068.6600341796875):  Now suppose I want to print these things out. (1070.5):  Let's just do something as a simple exercise. (1073.9000244140625):  So for int i equals 0, i is less than 3, i plus plus. (1078.5):  Inside of this loop, I'm going to do something simple (1080.6600341796875):  like print out iteratively, as you note, backslash n, list bracket i. (1087.780029296875):  So very simple program. (1088.93994140625):  It's not the best design because I've got this magic number there. (1091.780029296875):  I'm hard coding the 3. (1092.8599853515625):  But the point is just to go through the motions of demonstrating (1096.3800048828125):  how this code works. (1098.6600341796875):  Ah, good, you got it in before I hit compile. (1102.02001953125):  So wait, thank you. (1106.6600341796875):  Maybe a round of applause, thank you. (1110.1800537109375):  All right, so this is going to get aggressive, though, eventually. (1114.9000244140625):  So let me add the semicolon. (1116.93994140625):  Let me recompile this list. (1120.06005859375):  Seems to compile OK. (1121.3399658203125):  And if I do dot slash list, I should see, of course, 1, 2, 3. (1124.4599609375):  So the code works. (1125.5400390625):  There's no memory constraints here because I'm not (1127.6199951171875):  trying to actually add some values. (1129.1400146484375):  But let me consider how I could go about implementing (1132.8199462890625):  this idea of copying everything from the old array to the new array, (1136.3399658203125):  frankly, just to kind of see how annoying it is, how painful it is. (1140.06005859375):  So you're about to see the code escalate quickly. (1142.4200439453125):  And it will be helpful to try to wrap your mind around each individual step, (1146.739990234375):  even though if you take a step back, it's (1148.5):  going to look like a crazy amount of code to solve a simple idea. (1151.4599609375):  But that's the point. (1152.3800048828125):  We're going to get to a place, particularly in week 6, (1154.8199462890625):  where all of what we're about to do reduces to one line of code. (1158.3399658203125):  So hang in there for now. (1160.02001953125):  So let me go ahead and do this. (1161.3399658203125):  If I want to create a version of this code that (1165.6199951171875):  can grow to fit more numbers, for instance, how can I go about doing this (1170.780029296875):  or at least demonstrate as much? (1172.4200439453125):  Well, I cannot use an array in this traditional way (1176.260009765625):  of using square brackets because that makes list. (1180.4200439453125):  the variable forever of size 3. (1182.900043964386):  I can't free it. (1183.860044002533):  Remember, free, you can only use with malloc, so you can't give it back (1186.900043964386):  and then recreate it using this syntax. (1189.2200441360474):  But I can use this trick from last time, whereby (1191.9800443649292):  if I know there is this function called malloc whose purpose in life (1194.7800436019897):  is to give me memory, I could, for instance, (1197.060043334961):  redeclare list to be a pointer, so to speak, that (1200.8600444793701):  is the address of a chunk of memory. (1202.6600437164307):  And I could ask malloc for a chunk of memory, namely of size 3, (1207.1800441741943):  but not 3 per se, 3 integers for good measure. (1210.6600437164307):  So technically, that's 3 times the size of whatever an int is. (1215.0200424194336):  Now, for our purposes today, that's technically 3 times 4 or 12. (1218.5400428771973):  But I'm trying to do this very generally in case we use it on an old computer (1222.0200424194336):  or maybe a future computer where the size of an int might very well change. (1226.0200424194336):  That's why I'm using size of int. (1227.5000457763672):  It will tell me always the correct answer for my computer. (1230.620044708252):  So to use malloc, you're not going to catch me on this one, (1233.7400436401367):  what header file do I need to add? (1237.5800437927246):  Standard lib.h. (1240.3400421142578):  So I'm going to go ahead and include standard lib.h, which (1243.4200439453125):  gives me access to malloc. (1244.940040588379):  And what I'm going to additionally do is practice (1246.940040588379):  what I preached last week, whereby in extreme cases, (1249.9800415039062):  malloc can return not the address of an actual chunk of memory. (1253.8200454711914):  What else can malloc return in cases of error? (1257.5000457763672):  Yeah. (1258.8200454711914):  Null, N-U-L-L in all caps, which represents technically address 0, (1263.3400421142578):  but you're never supposed to use address 0. (1265.1400451660156):  So it's a special sentinel value that just means something went wrong. (1268.060043334961):  Do not proceed. (1269.1000442504883):  So it's going to add some bulk to my code, but it is good practice. (1271.9800415039062):  So if list at this point actually equals equals null, (1275.780044555664):  there's no more work to be done here. (1277.3200454711914):  I've got to abort the demo altogether. (1278.900047302246):  So I'm going to return 1 just arbitrarily (1280.7400436401367):  to say we're done with this exercise. (1282.5400466918945):  It's not going to be germane for class. (1284.160041809082):  We can surely find room for three integers, but best practice (1286.7000427246094):  whenever using malloc. (1288.940040588379):  Now, this code here does not need to change. (1291.780044555664):  Because list is now still a chunk of memory of size 12, (1296.4600448608398):  I can actually get away with still using square bracket notation (1299.3000411987305):  and treating this chunk of memory as though it's an array. (1303.0200424194336):  And this is a bit subtle, but recall from last time (1305.180046081543):  we talked briefly about pointer arithmetic, (1307.9600448608398):  whereby the computer can do some arithmetic, some addition, (1311.060043334961):  subtraction on the actual addresses to get from one location to the other. (1315.1000366210938):  And that's what the computer is going to do here. (1317.060043334961):  Because it says list bracket 0, that's essentially (1320.6800384521484):  just going to put the number 1 literally at the beginning (1324.7600402832031):  of that chunk of memory. (1325.9200439453125):  And because this is a modern computer, it's going to take 4 bytes in total. (1329.2400512695312):  But I don't want to put the number 4 here to shift it over myself. (1333.8800506591797):  Because I'm using square brackets, and because the computer knows (1337.6800384521484):  that this chunk of memory is being treated (1340.800048828125):  as a chunk of addresses of integers, pointer arithmetic (1344.3200378417969):  sort of magically kicks in. (1345.6000366210938):  So what the computer is going to do for me is put this 1 at location 0. (1350.280044555664):  It's going to put this number 2 at location 1 times size of int, so 4. (1355.800048828125):  And it's going to put this number 3 at location 2 times size of int, (1359.7200469970703):  which gives me 8. (1361.1200408935547):  So in other words, you don't have to think about how big that chunk of memory (1364.3200378417969):  is if you already gave the compiler a clue as to the size. (1368.0000457763672):  For our purposes today, don't worry too much about that. (1370.3200378417969):  The bigger takeaway is that when you allocate space using malloc, (1373.6400451660156):  you can certainly treat it as though it's an array using week 2 notation, (1378.1200408935547):  which is arguably simpler than using dots and stars and all of that. (1382.5200500488281):  But this isn't quite enough now. (1383.8400421142578):  Because let me stipulate that for the sake of discussion, (1386.7600402832031):  at this point in time here on line 16 where the cursor is blinking, (1391.2400512695312):  suppose I realize, just for the sake of discussion, (1393.7400512695312):  like, ah, I should have allocated space for four integers instead of three. (1398.0800476074219):  Now obviously, if I were writing this for real, (1400.3200378417969):  I should just go fix the code now and recompile it all together. (1403.280044555664):  But let's just pretend for the sake of discussion (1405.3200378417969):  that somewhere in your program, you want to dynamically allocate more space (1409.5200500488281):  and free up the old in order to implement this idea of copying (1413.280044555664):  from old to new memory. (1415.1200408935547):  So how could I do that? (1416.5200500488281):  Well, let me go ahead and temporarily give myself another chunk of memory. (1420.4200439453125):  And I'm going to literally call it TMP for short, which (1422.6200408935547):  is a common convention, temp. (1424.4800415039062):  I'm going to set that equal to the amount of space (1427.1600494384766):  that I actually do now want. (1428.6400451660156):  So I'm going to say four times the size of an int. (1431.5200500488281):  So technically, it'll give me 16, but space for four integers this time. (1435.4800415039062):  And what that's doing for me in code is essentially (1439.4000549316406):  trying to find me space for four integers elsewhere. (1443.6800537109375):  That might very well be garbage values now, but I can therefore reuse them. (1447.7200317382812):  So once I've done this, something could still go wrong. (1450.5200500488281):  And I could check if temp equals equals null, (1453.4000549316406):  then actually I should exit altogether and finish up. (1456.6400451660156):  But there's a subtlety here. (1458.7200317382812):  And you don't need to dwell too much on this for today. (1461.1800537109375):  But there is technically a bug right now. (1463.4000549316406):  Why, based on week four, last week, might it not be correct, technically, (1469.280029296875):  to immediately return one and abort the program altogether at this point? (1473.8800354003906):  AUDIENCE MEMBER 2. (1474.8800354003906):  When you allocate memory, sometimes there might be garbage values there. (1477.8800354003906):  OK, so when you allocate memory, sometimes there (1480.2000427246094):  might be garbage values there. (1481.4200439453125):  That is true, but that is to say that those 16 bytes might be garbage values, (1486.1600341796875):  have Oscar the Grouch's all on the screen. (1488.4400329589844):  But temp itself will literally be the return value of malloc. (1492.2400512695312):  And malloc will always return to you the address of a valid chunk of memory, (1496.3200378417969):  or it will return null. (1497.6400451660156):  So this line is actually OK. (1500.1200561523438):  What I don't love is that I'm returning one immediately. (1503.2000427246094):  AUDIENCE MEMBER 3. (1503.9600524902344):  Return null. (1506.4600524902344):  Yes, so this is where it's subtle. (1508.56005859375):  It's not quite right to just abort right now and return one. (1511.6800537109375):  Why? (1512.4000549316406):  Because up here, remember, a few moments ago, (1515.3600463867188):  we used malloc presumably successfully. (1518.280029296875):  Because if we got all the way down here, we did not abort on line 9, (1522.0400390625):  so we kept going. (1523.2000427246094):  But that means we've allocated three times size of it, so 12 bytes earlier. (1527.8400573730469):  So frankly, if you compile this code, run it, and then ask Valgrind, (1531.1200561523438):  it's going to identify a memory leak of size 12. (1534.0400390625):  Because as you know, we did not free the original memory. (1536.6400451660156):  So this is where, frankly, C does get a little annoying, (1538.9200439453125):  because you and I, as the programmers, have to remember all of these details. (1542.56005859375):  So what I really want to do here, before I return one, to be best practice, (1547.280029296875):  I want to free the original list. (1549.6800537109375):  So I give back those bytes to the operating system. (1552.3600463867188):  Now, as an aside, technically, when any program quits, (1554.9600524902344):  all of the memory is going to be given back to the operating system. (1557.7600402832031):  But practicing what I'm preaching now will get you into better situations (1561.6400451660156):  later, because if you don't free up memory, you will have leaks. (1565.4400329589844):  And that's when our own Macs and PCs tend to start to slow down and use up (1569.7200317382812):  more memory than they should. (1571.0000305175781):  But let's avoid discussion of more error checking there. (1573.9200439453125):  Let's just assume that now I'm on line 23 of this program, (1577.1600341796875):  whereby I have presumably successfully allocated enough space. (1580.9200439453125):  So the next step, after allocating these four bytes, (1583.6400451660156):  is to, as you noted earlier, iteratively copy the old numbers (1587.6800537109375):  into the new space. (1588.9600524902344):  So this is actually pretty straightforward. (1591.1200561523438):  I'm going to go ahead and for int i get 0, i is less than 3, (1595.4800415039062):  i plus plus, just like I was printing last time, (1598.8400573730469):  I'm going to go ahead and set the i-th location of temp (1602.5200500488281):  equal to the i-th location of list, semicolon. (1606.2400512695312):  And that's it. (1607.0000305175781):  I'm just copying into the temporary array whatever was in the old array. (1612.4000549316406):  But that still leaves me with this fourth byte, of course, (1615.4000549316406):  this fourth location, where I want to put the number 4. (1619.1000366210938):  But if I'm going to do that for the sake of discussion, (1621.3600463867188):  even though this isn't really a compelling real world program, (1624.4000549316406):  I'm going to just manually go into the last location in temp, (1629.0400390625):  a.k.a. temp bracket 3, and set that equal to my fourth number. (1633.8800354003906):  So that's all. (1634.800048828125):  The whole point here is to mimic in code what it was we wanted to do here. (1639.5200500488281):  But now there's one more step. (1640.8200378417969):  What was the next step after copying the 1, the 2, the 3, and adding the 4? (1644.7200317382812):  What do I want to do? (1646.7200317382812):  Now I can safely free the list. (1648.6400451660156):  Now I want to go ahead and get rid of the original memory, (1651.0800476074219):  or at least hand it back to the operating system. (1653.56005859375):  So here is where I can free the list, not in the case of an error, (1657.4800415039062):  but actually deliberately free the original list, (1660.4400329589844):  because I don't need those 12 bytes anymore. (1663.3200378417969):  But now if I want to really have quote, unquote, (1666.56005859375):  list point at this new chunk of memory, well, then I could also do this. (1671.4400329589844):  List equals temp. (1674.4800415039062):  So this is a little weird, but recall that list has just now been freed. (1677.7600402832031):  So even though list technically contains the address of a chunk of memory, (1680.9200439453125):  it's no longer valid. (1682.0000305175781):  Because, again, it was freed, so yes, it's still technically there, (1685.2000427246094):  but it's effectively garbage values now. (1687.2400512695312):  So I'm certainly free, no pun intended, I'm (1689.6800537109375):  certainly allowed to update the value of list. (1692.800048828125):  And I want list to now point to the new chunk of memory. (1696.1200561523438):  So sort of metaphorically, if list was originally (1698.1200561523438):  pointing at a chunk of memory there, maybe now I want it to point over here. (1701.6000366210938):  So I'm just updating the value of list ultimately. (1705.6000366210938):  All right, now that I've got this all done, (1707.4800415039062):  I think I can just use this same loop as before. (1709.800048828125):  I could change the 3 to a 4, because I now have four numbers. (1713.1200561523438):  At the very bottom of this program, though, also subtle, (1716.0400390625):  I should probably now, at the very end, free this list. (1719.2400512695312):  And for good measure, let me go ahead and return 0. (1723.2000732421875):  But now I think I have a complete program. (1725.2000732421875):  That, again, to be clear, is not how you would write this in the real world, (1728.6800537109375):  because you would not allocate three integers, (1732.1600341796875):  then decide you want to allocate four, then fix all of this. (1735.4800415039062):  But we could probably borrow, copy and paste some of this code (1737.9800415039062):  into production code eventually, whereby this would solve (1741.1400146484375):  some actual problems dynamically. (1743.1400146484375):  So let me cross my fingers, make list. (1745.3400268554688):  So far, so good, dot slash list. (1746.8600463867188):  And I should see 1, 2, 3, 4. (1750.5000610351562):  So long story short, it's a lot of work just (1753.1000366210938):  to get from the original array to the second. (1755.9800415039062):  So ideally, we would not do any of this in the first place. (1759.7200317382812):  Ideally, what could we do instead? (1762.2600708007812):  Well, maybe we should just allocate more memory from the get-go (1765.9800415039062):  in order to avoid this problem altogether. (1768.1400146484375):  So how might I do that? (1769.3800659179688):  Well, instead of having allocated an array of size 3, (1773.6000366210938):  let alone an array of size 4, why don't I just proactively (1776.5400390625):  from the beginning of my program allocate an array of size 30, (1779.820068359375):  or heck, 300, or 3,000, and then just keep track of how much of it (1784.2200317382812):  I'm using? (1786.06005859375):  That would be correct. (1787.5400390625):  It would solve the problem of not painting yourself (1790.2200317382812):  into a corner so quickly. (1792.9000244140625):  But what remains as an issue? (1796.1000366210938):  I'm using a bunch more memory, especially if this program is only (1799.02001953125):  going to ever manage a few numbers. (1800.4800415039062):  Why are you wasting 100 times more memory than you might actually? (1804.4600219726562):  And there's another corner case that could still arise, (1807.06005859375):  even though this sort of solves the problem. (1809.2600708007812):  AUDIENCE MEMBER 2 If you add another list, you don't have enough memory. (1812.0000610351562):  DAVID J. MALANY I exactly. (1812.5800170898438):  We can eventually still run into the exact same problem, (1815.1800537109375):  because if I want to put 301 numbers in the list, or 3,001, (1818.5800170898438):  well, I'm still going to have to jump through all of these hoops (1821.1800537109375):  and reallocate all of that space. (1823.02001953125):  And honestly, now, per your concern about the looping, (1825.9000244140625):  iterating 300 times 3,000 times is certainly (1829.3400268554688):  eventually going to start to add up, if we're doing it a lot, (1832.1000366210938):  in terms of speed and slowdown. (1834.02001953125):  So maybe there's a better way altogether than doing this. (1837.7400512695312):  And indeed, there is, if we start to treat our computer's memory as a canvas (1842.1000366210938):  that we can start to use to design data structures more generally. (1845.820068359375):  Arrays are a data structure, arguably. (1847.5400390625):  They're super simple. (1848.4600219726562):  They're contiguous chunks of memory. (1850.1800537109375):  But we could use memory a little more cleverly, (1853.6200561523438):  especially now, per last week, that we have pointers, (1855.9000244140625):  which is sort of painful as they might be to wrap your mind around sometimes. (1859.5400390625):  They really just let us point to different places in memory. (1862.780029296875):  And so we can start to stitch things together in an interesting way. (1866.4600219726562):  So the only syntax we'll really need to do that, (1869.8600463867188):  to sort of stitch things together in memory (1872.820068359375):  and build more interesting structures, are these things. (1875.2600708007812):  struct, which allows us to represent structs already. (1878.2600708007812):  And we did this with persons. (1879.820068359375):  And we played with this last time as well. (1881.5800170898438):  And we saw it already for queues and stacks. (1884.4200439453125):  The dot operator, we haven't used it that much. (1886.9400634765625):  But recall that whenever you have a struct, (1889.2200317382812):  you can go inside of it using the dot operator. (1891.5000610351562):  And we did that for a person, person.name and person.number, (1895.300048828125):  when we were implementing a very simple address book. (1897.9000244140625):  The star was new last week. (1899.5400390625):  And it can mean different things in different contexts. (1901.780029296875):  You use it when declaring a pointer. (1904.1400146484375):  But you also use it when dereferencing a pointer, to go there. (1908.02001953125):  But just so you've seen it before, it actually (1910.4600219726562):  tends to be a little annoying, a little confusing, (1912.7400512695312):  to use star and dot together. (1914.6600341796875):  You might remember one example last week where in parentheses, (1917.5400390625):  I put star something. (1918.8600463867188):  And then I used a dot operator to go there and then go inside the structure. (1923.1400146484375):  Long story short, we'll see today that you (1925.1800537109375):  can combine simultaneous use of star and dot (1928.5400390625):  into something that actually looks like an arrow, something that vaguely (1931.9000244140625):  looks like a foam finger that might be pointing from one place to another. (1936.3400268554688):  So we'll see that actually in some code. (1939.02001953125):  So where can we take this? (1941.9400634765625):  Well, let's implement the first of these ideas, namely, (1944.6600341796875):  something that's very canonical in computing, known as a linked list. (1949.2600708007812):  And let's see if we can maybe do this. (1952.3800659179688):  How about Scully? (1954.06005859375):  Could we get you to come on up and volunteer here? (1956.7000732421875):  So our friend Scully, there's some cookies in this for you. (1959.9000244140625):  So Scully's come prepared with a whole bunch of balloons (1962.3400268554688):  to represent chunks of memory because we'd like to paint a picture here (1965.780029296875):  of what's involved in actually allocating space that's not necessarily (1969.3800659179688):  contiguous and might be over there or over here (1971.6600341796875):  or over here in the computer's memory. (1973.5400390625):  So for instance, if I want to start allocating space one (1977.3800659179688):  at a time for a list of numbers, Scully, could you (1979.8600463867188):  go ahead and malloc one balloon for me? (1982.02001953125):  And in this balloon, I'll store, for instance, the number one ultimately. (1985.9800415039062):  So we have a balloon here. (1987.7400512695312):  We've rehearsed this before. (1988.9400634765625):  And these balloons are actually really hard to blow up and tie off quickly. (1992.1800537109375):  So thank you. (1992.780029296875):  So here we have a chunk of memory. (1994.5400390625):  And I could certainly, for instance, go in here and store, if I might, the, (2000.06005859375):  here we go. (2000.7400512695312):  I could certainly go ahead here and store in this balloon, (2003.4200439453125):  for instance, the number one. (2005.4600219726562):  But in the world of an array, it would just be back to back to back. (2008.6200561523438):  And actually, frankly, why do we need the balloons even? (2010.9800415039062):  I could just use these numbers, one, two, three. (2013.2200317382812):  But the problem does indeed arise, note, that when (2015.8400268554688):  we want to put a fourth number, well, where does it go? (2018.300048828125):  Well, again, just to paint a picture, ideally, I might allocate space for four. (2023.7400512695312):  But if this is my array of size three, where does it go? (2027.02001953125):  This is the point. (2027.780029296875):  We can't just put it next to the three. (2030.2200317382812):  Maybe there's room for the four over here. (2032.5000610351562):  But we have to somehow connect these from one to the other. (2035.6200561523438):  So in fact, let's sort of act that out. (2037.2600708007812):  So if I instead use this balloon metaphor of just allocating space (2040.2200317382812):  from wherever it is, can you go ahead and allocate another chunk of memory (2043.2200317382812):  for me? (2044.4600219726562):  And here is where I'll now have a chunk of memory (2047.4200439453125):  in which I can store the number. (2050.300048828125):  Computer's a little slow. (2052.9000244140625):  So in here, the second balloon, I'll have a separate chunk of memory. (2059.2600708007812):  There we go. (2060.1400146484375):  OK, good. (2061.780029296875):  Second chunk of memory. (2062.820068359375):  Thank you, Scully. (2066.06005859375):  Now I can certainly now store the number two in this chunk of memory. (2074.1000366210938):  But it's not necessarily contiguous. (2075.5800170898438):  Like, this chunk came from over here, as per Scully's position originally. (2078.9400634765625):  This chunk, obviously, is coming from over here. (2080.5000610351562):  And if you don't mind holding that for a moment, (2082.5400390625):  it's breaking the metaphor of an array, which was indeed contiguous. (2086.3400268554688):  And even though I, as the human, can certainly (2088.2600708007812):  go over and walk next to her, that's the equivalent of copying values (2091.1800537109375):  from one place to another. (2092.3800659179688):  What if we're a little more clever, though? (2094.1800537109375):  And if Scully found space for this number one over here, (2096.8600463867188):  let's just leave this balloon here. (2098.3800659179688):  And if she found space for the number two over there, (2100.5800170898438):  let's leave that balloon there. (2102.02001953125):  But we do somehow have to connect these numbers together. (2106.2600708007812):  And here is where, too, I'll try to do this on the fly. (2109.02001953125):  Maybe I could do something like this. (2110.8600463867188):  I can take this balloon here, and I can actually tie a string to it (2115.1400146484375):  so that if I want to connect one to the other, (2117.9400634765625):  we can sort of link these, if you will, together. (2121.2200317382812):  And so here now, I have a linked list that is not necessarily contiguous. (2125.06005859375):  There's a whole bunch of memory that may very well have real values, (2128.3400268554688):  may very well have garbage values. (2129.9000244140625):  But I've somehow now linked these two together. (2132.4200439453125):  And maybe just as a final flourish, if we could blow up one more balloon (2136.02001953125):  to represent more space. (2137.5800170898438):  And now she's finding room for that balloon over there. (2142.9000244140625):  Nice. (2143.5800170898438):  This one is a Yale chunk of memory. (2146.2200317382812):  So now I'll need one more link, if you will. (2153.02001953125):  And if I actually connect these two in this way, (2156.2200317382812):  let me go ahead and tie this off here. (2159.5400390625):  Now I can go ahead and connect these two. (2163.2600708007812):  If you never see this demonstration again in next year's videos, (2166.02001953125):  because this did not go very well, here now we have the number one (2170.300048828125):  where we first malloced it, the number two roughly where we next malloced it, (2174.1400146484375):  and the number three. (2175.780029296875):  OK, so maybe we'll fix this some other year. (2178.4600219726562):  Now we'll have the number three allocated there. (2180.5000610351562):  But the whole point of this silly exercise (2182.820068359375):  is that we can certainly use the computer's memory as more of a canvas, (2186.9000244140625):  put things wherever we want, wherever is available, (2190.1400146484375):  so long as we somehow connect the dots, so to speak, (2193.9800415039062):  and can make our way from one chunk of memory to the next to the next, (2197.6600341796875):  thereby literally linking them together. (2200.3400268554688):  But of course, we're using balloons for this metaphor. (2202.6200561523438):  But at the end of the day, this is just memory. (2204.6199951171875):  So how could we, in code, link one chunk to another chunk to a third chunk, (2210.340087890625):  might you think? (2211.260009765625):  What's the trick? (2211.9801025390625):  Yeah. (2213.260009765625):  Using pointers, right? (2214.340087890625):  That's why we introduced pointers last week. (2216.2200927734375):  Because as simple as an idea as it is, as hard as it (2218.580078125):  is to write sometimes in code, it's literally just a pointer, (2222.4200439453125):  sort of a foam finger pointing to another chunk of memory. (2225.6199951171875):  And so these pointers really are metaphorically (2227.6199951171875):  being implemented now with these pieces of string. (2230.1800537109375):  So we'll have to debrief later and decide if we ever do this demo again. (2233.2200927734375):  But thank you to Scully for participating. (2235.3800048828125):  OK. (2235.8800048828125):  We have plenty of, oh, OK. (2241.02001953125):  But bear's hair. (2244.2200927734375):  There we go. (2244.739990234375):  Thank you to Scully. (2245.9000244140625):  So let's now actually translate this to something a little more concrete (2250.02001953125):  and then get to the point where we can actually solve this problem in code. (2253.2200927734375):  So here's that same canvas of memory. (2255.300048828125):  And if in this canvas of memory now I actually (2257.820068359375):  want to implement this idea of the number 1, the number 2, the number 3, (2261.260009765625):  let's stop tying our hands in terms of expecting our memory (2264.739990234375):  to be contiguous back to back and start to move away from using arrays. (2268.7000732421875):  So for instance, suppose I want a malloc space for the number 1, (2271.820068359375):  just as Scully, I first asked of Scully. (2274.1400146484375):  Suppose it ends up over there on the board. (2276.02001953125):  The important thing for discussion here is that that number 1, (2278.9801025390625):  wherever it ends up, is surely located at some address. (2282.739990234375):  And for the sake of discussion, as in the past, (2284.9000244140625):  suppose the number 1 just ends up at location 0x123. (2288.580078125):  So 0x123 is where Scully was originally standing right here. (2292.10009765625):  Then we asked for malloc for another chunk of memory. (2295.06005859375):  Suppose that it ends up over here at address 0x456. (2299.06005859375):  So that's maybe roughly here when Scully was standing in her second position. (2302.5):  Lastly, we allocate the number 3. (2304.580078125):  Maybe it ends up at location 0x789, which was, again, (2307.7000732421875):  Per Scully's third malloc, roughly over here on stage. (2311.780029296875):  Now, this picture alone doesn't seem to lend itself (2314.9000244140625):  to an implementation of the string, metaphorically, to the pointers (2319.06005859375):  unless we allow ourselves a new luxury. (2322.1800537109375):  Instead of just storing the number 1, 2, 3 in our usual squares, (2328.02001953125):  I think what I'm going to have to do is kind of cheat and use more memory (2331.6199951171875):  to store what? (2332.7000732421875):  The pointers, as you proposed. (2334.8599853515625):  So here's a trade-off that I promised we would sort of start (2337.4600830078125):  to see more and more. (2338.580078125):  If you want to improve your performance in terms of time (2343.06005859375):  and avoid stupid copying of data from one place to another (2346.2200927734375):  again and again and again, if you want to save time, (2348.9400634765625):  you're going to have to give up some space. (2350.739990234375):  And there's going to be this trade-off between time and space. (2353.320068359375):  And it's up to you to decide, ultimately, which is more important. (2356.1400146484375):  So if you allow yourself not enough memory for the numbers 1, 2, and 3, (2360.06005859375):  but you want to save time, you're going to have to give up some space. (2363.4600830078125):  twice as much memory for the numbers 1, 2, and 3, and three pointers, (2367.86008310318):  one for each, what could we now do? (2370.820083141327):  Well, if this node, and this is a computing term, (2373.5800828933716):  like node is just a generic term describing (2376.1400833129883):  like a box of memory, a chunk of memory in this case. (2379.1400833129883):  If I've given you this blank slate here, what value (2382.820083618164):  would make sense to store here if it's associated with this number 1? (2388.420082092285):  Yeah? (2388.940082550049):  AUDIENCE MEMBER 2 Maybe the address of the next element. (2390.820083618164):  Good. (2391.320083618164):  Maybe the address of the next element. (2393.020082473755):  So the next element technically is supposed to be the number 2. (2396.2800827026367):  So at this location, I'm going to store the value 0x456. (2400.6400833129883):  What then logically should go here in the second box? (2404.0800819396973):  0x789. (2406.4000816345215):  And then here's a little non-obvious. (2408.2400817871094):  It's the end of the list as of now. (2410.5600814819336):  So we can't afford to let it be a garbage value, (2412.940082550049):  because a garbage value is a value. (2414.5600814819336):  And we don't want Oscar to effectively be pointing to some random location (2418.2400817871094):  lest we go there. (2419.7000846862793):  So what would be a good special value to put here to terminate a list? (2423.980083465576):  So null. (2424.7800827026367):  So not N-U-L, which we used for strings. (2426.940082550049):  But same idea, N-U-L-L, which we keep using now for pointers. (2431.1800842285156):  Otherwise known as the 0 address, which I could just (2433.700080871582):  write for shorthand as 0x0 in this case, which is the same thing as null. (2438.820083618164):  So here then, even though we've changed nothing about how a computer works, (2442.940086364746):  this is just my computer's memory, I'm using more memory now (2446.300079345703):  to effectively link one chunk to the next chunk to the next chunk. (2450.440086364746):  So easy to note that the downside is more space. (2454.00008392334):  But now we don't have to worry about ever copying and moving this data (2458.600082397461):  around, which maybe over time for really big programs, big data sets, (2462.5600814819336):  could very well be a net positive and a win for us. (2466.4000854492188):  So any questions first on this notion of what a linked list actually is? (2473.7600860595703):  No? (2474.2600860595703):  All right. (2474.7600860595703):  Well, recall from last time, too, that rarely do we actually (2477.700080871582):  care what the specific addresses are. (2479.3400802612305):  So this is one node, two node, and three nodes. (2481.7400817871094):  And inside of each of these nodes is two values, the actual number (2485.320083618164):  we care about, and then a pointer, which now this is actually (2488.980079650879):  an opportunity to introduce a term that you might see increasingly nowadays, (2492.100082397461):  data. (2492.9000854492188):  So 1, 2, and 3, which we obviously care about in this case. (2495.9800872802734):  And then we could actually refer to these pointers more generally (2498.9400787353516):  as metadata. (2500.2200775146484):  Like, it's actual data, because it's helping me solve a problem, (2502.9400787353516):  get from one place to another. (2504.560089111328):  But metadata is distinct from data in that I don't fundamentally (2507.560089111328):  care about the metadata. (2509.120086669922):  That's like an implementation detail, but it (2511.1600799560547):  does help me organize my actual data. (2514.0000762939453):  So this is more of a high-level concept. (2515.9200897216797):  So what, though, is a linked list? (2517.560089111328):  It turns out the store linked list will generally use just one more value. (2521.7200775146484):  And I'm going to draw it only as a square, a single box, (2524.6800842285156):  because if I declare now in my code, as I soon will, (2527.6400756835938):  a variable, maybe called list, that points to a node, (2532.5000762939453):  this is effectively how I could implement a linked list. (2535.9800872802734):  I use one node per value, and I use one extra pointer (2540.100082397461):  to find the first of those nodes. (2543.1400756835938):  And in fact, here again is where I don't need to care fundamentally (2546.340087890625):  where any of these addresses are. (2547.9000854492188):  It suffices to know that, yes, computers have memory addresses. (2551.5000762939453):  So I could just abstract this away, and this (2554.0200805664062):  is how I might pictorially represent a linked list, a cleaner (2557.340087890625):  version of those three balloons, whereby I was here. (2560.6800842285156):  This was Scully's first balloon, second balloon, third balloon. (2564.0000762939453):  These arrows now just represent pointers or strings with the balloons. (2568.320083618164):  So with that said, how can we go about translating this to some actual code? (2573.7600860595703):  Well, here's where we can call into play some of that same syntax (2577.4800872802734):  from last time and even a couple of weeks (2579.560089111328):  ago when we introduced the notion of a structure. (2582.5200805664062):  So here, for instance, is how we defined a couple of classes (2585.1600799560547):  ago the notion of a person. (2586.7600860595703):  Why? (2587.360076904297):  Well, C doesn't come with a person data type, (2589.560089111328):  but we concluded it was sort of useful to be (2591.620086669922):  able to associate someone's name with their number and maybe even (2594.540084838867):  other fields as well. (2596.1600799560547):  So we typedefed a structure containing these two values. (2599.6600799560547):  We learned last week that string is technically char star, (2602.1800842285156):  but that doesn't change what the actual structure is, (2604.5000762939453):  and we call this struct a person. (2606.7400817871094):  Well, here's what we revealed last time. (2609.2600860595703):  Again, taking those training wheels off, it's just a char star. (2611.880081176758):  Let's keep going in this direction, though. (2614.060089111328):  If I want to define not a person, but maybe more generically something (2617.120086669922):  I'll call today a node, like a container for my numbers and my pointers, (2621.9600830078125):  well, I similarly just need two values, not a name and a number, (2624.9600830078125):  which isn't relevant today, but maybe the number as an actual int (2629.10009765625):  so I can store the 1, the 2, the 3, the 4, and so forth. (2632.9600830078125):  And this is a little less obvious, but conceptually, (2635.7600708007812):  what should be the second value inside of any of these nodes? (2640.0000915527344):  Yeah, so indeed a pointer. (2642.120086669922):  A pointer to what, though? (2644.4400939941406):  A pointer to another node. (2646.300079345703):  And here's where the syntax gets a little weird, (2648.7400817871094):  but how do I define there to be a pointer in here to another node? (2654.380096435547):  Well, you might be inclined to say node star next, (2658.4200744628906):  because this means next is the name of the property or the attribute, (2661.820068359375):  the variable inside the struct. (2663.380096435547):  Star means it's a pointer. (2664.9400939941406):  What is it a pointer to? (2665.860076904297):  Clearly a node. (2666.860076904297):  But here's where C can kind of bite you. (2669.0200805664062):  The word node does not exist until you get to this last line of code, right? (2674.060089111328):  C goes top to bottom, left to right. (2675.840087890625):  So you literally can't use the word node here if it's not existing until here. (2681.1600952148438):  The simple fix for this is to actually use a slightly more verbose way (2684.4800720214844):  of defining a structure. (2685.840087890625):  You can actually do this. (2686.9600830078125):  And we didn't bother doing this with person (2688.5200805664062):  because it didn't solve a problem. (2690.0000915527344):  But if you actually make your first line a little more verbose (2692.7600708007812):  and say give me a definition for a structure called node, now in here, (2698.6400756835938):  you can actually do this. (2701.2400817871094):  This is sort of an annoying implementation detail (2703.7400817871094):  when it comes to implementing structures in C. (2705.860076904297):  But essentially, we're leveraging the fact that because C code is read from (2708.820068359375):  top to bottom, if you give this structure a name called struct node, (2713.2600708007812):  now you can refer to it here. (2715.2600708007812):  But you know what? (2716.0200805664062):  It's annoying to write struct node, struct node, struct node (2718.6600952148438):  everywhere in your code. (2719.820068359375):  So this last line now just gives you a synonym. (2722.0200805664062):  And it shortens struct node to just node. (2725.4200744628906):  So long story short, this is a good template (2727.4200744628906):  for any time you implement some notion of a node, as we will today. (2731.7800903320312):  But it's fundamentally the same idea as a person just containing now (2735.120086669922):  a number and a pointer to the next as opposed (2738.0000915527344):  to someone's name and phone number. (2740.2400817871094):  So let me go ahead and walk through with some code how we might actually (2744.080078125):  implement this process of allocating a balloon and putting a number on it, (2748.880096435547):  allocating another balloon and putting a number on it, (2751.4400939941406):  and then connecting those two balloons again and again. (2754.4800720214844):  So we'll do this step by step in a vacuum. (2756.9600830078125):  So you can see the syntax that maps to each of these ideas. (2759.9200744628906):  Then we'll actually pull up VS Code and combine it all (2762.4200744628906):  and make a demonstrative program. (2764.7000732421875):  So here, for instance, is the single line (2767.10009765625):  of C code via which I can give myself the beginning of a linked list. (2771.060089111328):  That is a pointer that will eventually be pointing to something. (2774.380096435547):  So sort of metaphorically, it's like creating a pointer, right? (2777.060089111328):  I know we've gotten some complaints about that in the audience. (2780.1400756835938):  We'll use the Harvard one to represent a pointer to something. (2783.320068359375):  But if I only do this, and I only say give me (2786.380096435547):  a variable called list that is a pointer to a node, (2790.1600952148438):  that's going to leave a garbage value. (2792.5200805664062):  So this is like pointing to some random location (2794.60009765625):  because it's previously some value. (2796.4800720214844):  Who knows what it is? (2797.560089111328):  But we can solve that how? (2798.9200744628906):  What would be a good initial value to set this equal to? (2804.320068359375):  So null. (2805.0000915527344):  At least if it's null, we then know that this isn't a garbage value. (2808.2400817871094):  This is literally 0x0, a.k.a null, and I'm just (2811.4000854492188):  going to leave it blank for cleanliness. (2813.1800842285156):  So this would be the right way to begin to create a linked list of size 0. (2817.7000732421875):  There's nothing there, but at least now that foam finger (2820.4200744628906):  is not pointing to some bogus chunk of memory, some garbage value. (2824.0200805664062):  So this is how the world might exist now in the computer's memory. (2827.560089111328):  How do I go about allocating space now for a node? (2830.340087890625):  Well, it's just ideas from last week. (2832.380096435547):  Once the word node exists, as via that typedef, (2836.4200744628906):  I can just use malloc to ask for the size of a node. (2840.4200744628906):  I don't have to do the math myself. (2841.9200744628906):  I don't care how big a node is. (2843.4000854492188):  Just let it do the math for me. (2845.6800842285156):  Then that's going to return presumably the address of a chunk of memory (2849.120086669922):  big enough for that big rectangle. (2851.4800720214844):  And I'm going to store that for now in a temporary variable called n that (2855.4600830078125):  itself is a pointer to a node. (2857.4800720214844):  So this might look like a lot altogether, (2859.4800720214844):  but this is just like before when I allocated space for a string (2863.7200927734375):  or I allocated space for a bunch of numbers (2866.0000915527344):  and set it equal to a pointer to integers, for instance, most recently. (2871.860076904297):  So this gives me a box in memory. (2874.4200744628906):  This gives me a pointer called n. (2876.7800903320312):  So it's similarly just a single square because it's just an address. (2879.820068359375):  And it similarly gives me a bigger chunk of memory (2881.9801025390625):  somewhere in the computer's memory containing (2884.2600708007812):  enough space for the number that's going to go there, a 1, a 2, a 3, (2888.10009765625):  or whatever, and a pointer to the next value. (2891.2200927734375):  So these lines of code collectively, this half creates this in memory. (2894.9000854492188):  This half creates this in memory. (2896.9000854492188):  And the assignment here, the equal sign, (2899.60009765625):  essentially does the equivalent of that. (2901.60009765625):  I don't care what the address is, the actual number. (2903.8001098632812):  It's as though n is now pointing to that chunk of memory. (2906.8001098632812):  But this isn't very useful. (2908.4400634765625):  If I want to store the number 1 here, with what code can I do that? (2912.2800903320312):  Well, I could do this, borrowing an idea from last week. (2915.360107421875):  So star n presumes that n is a pointer. (2919.0000610351562):  Star n means go there, go to whatever you're pointing at. (2922.8800659179688):  The dot operator means if you're pointing at a structure, (2925.4400634765625):  go inside of it to the number field. (2927.7800903320312):  And we did this a couple of weeks ago with number and person (2931.2600708007812):  when we implemented an address book. (2932.9000854492188):  So star n is go there. (2934.580078125):  And the dot operator means go to the number field. (2937.5401000976562):  The 1 on the right-hand side and the equal sign means set whatever is there (2940.820068359375):  equal to the number 1. (2942.9000854492188):  It turns out this is the syntax, though, that I alluded (2945.340087890625):  to being a little bit cryptic and not very pleasant to remember or type. (2949.2401123046875):  Here, though, is where you can synonymously instead (2952.4801025390625):  use this line of code, which most C programmers would use instead. (2956.080078125):  This means n is still a pointer. (2958.0401000976562):  The arrow, literally, with a hyphen and a greater than sign means go there. (2963.0000610351562):  It's the exact same thing as the parentheses (2965.5200805664062):  with the star with the dot. (2967.4000854492188):  This just simplifies it to look like these actual pictorial arrows. (2971.1200561523438):  So this would be the most conventional way of doing this. (2973.4801025390625):  How now do I update the next field? (2975.4400634765625):  Well, I think I'm going to just say the same thing, n, go there, (2979.1600952148438):  but go into the next field and set it equal to null. (2983.2401123046875):  Why null? (2984.0401000976562):  If the whole point here was to allocate just one chunk of memory, (2987.7401123046875):  one node, you don't want to leave this as a garbage value (2990.7401123046875):  because that value will be mistaken for an arrow pointing (2993.340087890625):  to some random location. (2996.2600708007812):  All right, that's a lot. (2997.340087890625):  And again, we're doing it in isolation, step (2999.2200927734375):  by step, just to paint the picture on the screen. (3001.3001098632812):  But any questions on any of these steps? (3006.10009765625):  Each picture translates to one line of code there. (3009.3800659179688):  All right, so if you're comfy enough with those lines there, (3014.8001098632812):  what can I proceed to now do? (3017.3001098632812):  Well, let me propose that what I could now do with this same approach (3023.0401000976562):  is set list itself equal to n. (3024.9600830078125):  Because if the whole goal is to build up a linked list (3027.2000732421875):  and list represents that linked list, list equals n (3030.5000610351562):  is essentially saying whatever address is here, put it here. (3033.4000854492188):  And pictorially, what that means is temporarily point both pointers (3036.840087890625):  to the same exact place. (3037.9600830078125):  Why? (3038.6200561523438):  Because this is the list that I care about long term. (3040.580078125):  This is maybe my global variable that I'm (3042.3001098632812):  going to keep around forever in my computer's memory. (3044.860107421875):  This was just a temporary pointer so that I could get a chunk of memory (3047.9400634765625):  and go to its locations and update it with those values. (3050.9400634765625):  So eventually, this is probably going to go away altogether. (3053.820068359375):  And this, then, is a linked list of size 1. (3056.2200927734375):  This is what happened when Scully inflated one balloon. (3058.6600952148438):  I wrote the number 1 on it, and I pointed at that single balloon. (3063.0200805664062):  All right, if I want to go ahead and do this again and again, (3065.860107421875):  we'll do this a little more quickly. (3067.4000854492188):  It's the same kind of code for now. (3069.4600830078125):  Here's how I allocate space for another node. (3072.4201049804688):  Here's how I can temporarily store in n, and I'll (3074.820068359375):  redeclare it here just to make clear that it's indeed just a pointer. (3077.7401123046875):  So the left-hand side of the expression gives me this. (3080.06005859375):  The right-hand side of the expression gives me this. (3082.06005859375):  Where could it be? (3082.860107421875):  I mean, I put it here. (3083.8001098632812):  It could have been there. (3084.5401000976562):  It could have been anywhere else, but malloc gets to decide that for us. (3088.2200927734375):  n equals this just sets that temporary pointer (3091.6200561523438):  equal to that chunk of memory. (3093.2200927734375):  I should clean this up. (3094.4201049804688):  How do I now put the number 2 into this node? (3097.3800659179688):  Well, I start at n, I go there, I go to the number field, (3101.080078125):  which I keep drawing on top, and I set it equal to 2. (3104.0401000976562):  Now, it's a little non-obvious what we should do here. (3107.7200927734375):  So I'm going to be a little lazy at first. (3109.8800659179688):  And rather than put these numbers into the linked list in sorted order, (3113.4801025390625):  like ascending order 1, 2, 3, 4, I'm just (3115.56005859375):  going to plop it at the beginning of the list. (3117.5200805664062):  Why? (3117.8001098632812):  Because it's actually a little simpler. (3119.4400634765625):  If the h time I allocate a new node, I just (3121.6400756835938):  prepend it, so to speak, to the beginning of the list, (3124.2401123046875):  even though it's going to end up looking backwards in this case. (3127.2800903320312):  So notice, at this point in the story, I've (3129.6200561523438):  got list pointing to the original linked list. (3132.580078125):  I've got n pointing to the brand new node. (3135.6800537109375):  And ultimately, I kind of want to connect these just (3138.820068359375):  as Scully and I did with the strings. (3140.4201049804688):  This is just temporary, so I want to connect these things. (3143.3800659179688):  Here's how I could do it wrong. (3145.1800537109375):  If I proceed now and update, oh, rather, after one more line setting (3149.580078125):  this equal to null, sorry, let's at least get rid of that garbage value, (3153.320068359375):  here's how I could proceed to maybe do this wrong. (3155.9600830078125):  Let me go ahead and update, for instance, list equals n. (3160.9201049804688):  So if I update list equaling n, that's going (3164.7200927734375):  to point the list at this new node. (3168.4000854492188):  But what has just happened? (3171.4000854492188):  What did I do wrong? (3172.2000732421875):  Yeah. (3173.9201049804688):  So nothing's pointing to 1. (3175.4400634765625):  And even though you and I obviously have this bird's eye view of everything (3178.2800903320312):  in the computer's memory, the computer doesn't. (3180.2800903320312):  If you have no variable remembering the location of that node, (3183.0000610351562):  for all intents and purposes, it is gone. (3185.06005859375):  So what I've essentially done is this. (3186.6600952148438):  When I update that pointer to point at the number 2, (3189.10009765625):  it's as though this was a much nicer idea in theory when we talked about it, (3192.580078125):  but it's not really working. (3193.7800903320312):  But this is effectively what we've tried to achieve, which is I've (3196.9801025390625):  orphaned, so to speak, the number 1. (3198.7401123046875):  And that 2 is a technical term in the context of memory. (3201.1800537109375):  If no one is pointing at it, if no string is connected to it, (3204.4201049804688):  I have indeed orphaned a chunk of memory, a.k.a. (3207.06005859375):  a memory leak. (3207.9801025390625):  And Valgrind would not, in fact, like this. (3210.1800537109375):  And Valgrind would, in fact, notice this. (3212.860107421875):  So what would be the better approach? (3215.8001098632812):  Let me rewind. (3216.840087890625):  Instead of updating that address to be that of this node, (3220.5200805664062):  let's rewind to where we were a moment ago, (3223.080078125):  where list is still pointing at the original, (3225.2000732421875):  and is still pointing at the new chunk of memory. (3227.2401123046875):  And what should I do instead? (3228.8800659179688):  Well, what should I do is maybe this. (3231.2401123046875):  Let's go to the next field of the new node. (3235.0000610351562):  So follow the arrow, go to the next field. (3237.7200927734375):  And what should I put here instead? (3240.0000610351562):  Why don't I put the memory address of the original node? (3244.340087890625):  How can I get that? (3245.3800659179688):  Well, that's actually this. (3246.860107421875):  So if list is pointing at the original node, (3249.3800659179688):  I can just copy that address into this next field, which (3252.9801025390625):  has the effect of doing that, albeit in duplicate. (3256.7800903320312):  I've updated the next field to point at the very thing (3259.7401123046875):  that the original list is already pointing at. (3262.4201049804688):  And now, for the sake of discussion, let me get rid (3264.580078125):  of my temporary node called n. (3266.9400634765625):  And what you'll see ultimately is that once we set list equal to n (3273.2200927734375):  and get rid of it, now we can just treat the whole linked list (3278.2800903320312):  as being connected and linked in this way. (3281.580078125):  How do we do this? (3282.360107421875):  Again, we won't belabor the point with more. (3284.2000732421875):  But suppose I want to allocate a third node. (3286.0401000976562):  I have to do the exact same thing. (3287.4801025390625):  But I have to update this next field to point at the existing list (3291.60009765625):  before I update list itself. (3293.2800903320312):  Long story short, order of operations is going to be super important. (3297.4000854492188):  And if I want to stitch these data structures together, (3300.2000732421875):  I would encourage you to think ultimately, (3302.080078125):  certainly when it comes time to write something like this, (3304.5401000976562):  think about what it is that we're actually trying to tie together. (3308.5401000976562):  So let me go ahead and do this. (3310.06005859375):  I'm going to go over to VS Code here. (3312.580078125):  I'm going to delete the old code for list.c. (3315.2600708007812):  And perhaps now we can transition away from our old approach (3318.7800903320312):  and actually do something with these pointers instead. (3322.9000854492188):  So I'm going to go ahead and, let's say, include as before. (3328.0200805664062):  Include standard io.h. (3330.4801025390625):  Let's go ahead and include standard lib.h proactively. (3334.2800903320312):  And let's go ahead and create that data type. (3336.1600952148438):  So type def, a struct called node. (3339.4801025390625):  And inside of this node, let's give us an integer called number (3342.7600708007812):  to store the 1, the 2, the 3, the 4. (3344.8001098632812):  And then let's create a struct node star value (3347.7200927734375):  called next, whose purpose in life is going to point to the next node (3351.0000610351562):  in any such list. (3352.2800903320312):  I'm going to shorten the name of all this to just node simply. (3355.7200927734375):  And then in main, let's go ahead and do this. (3358.0401000976562):  We'll bring back our friend argc and argv so that I can actually (3361.9400634765625):  implement a program this time that lets me construct a linked list using numbers (3365.4600830078125):  that I just pass at the command line. (3366.9600830078125):  I don't want to bother with get int again and again or the CS50 library. (3370.340087890625):  So let's just use argc and argv. (3374.820068359375):  But with argv, recall string now, as of last week, is synonymous with char star. (3379.6200561523438):  So that's the exact same thing as we've used in week 2 (3383.1400756835938):  onward for command line arguments. (3385.4600830078125):  So what do I want to do? (3386.60009765625):  My goal in life with this demonstration is (3388.6800537109375):  to create in code this linked list here, or at least the beginnings thereof. (3394.60009765625):  So how can I do this? (3395.9200439453125):  Let me go back into VS Code. (3397.7200927734375):  Let me declare a linked list called list, but initialize it to null. (3401.9200439453125):  So there's nothing there just yet. (3404.56005859375):  How now can I go about building this linked list (3408.7200927734375):  by taking numbers from the command line? (3410.6800537109375):  So let's do this. (3411.9600830078125):  For int i equals 1, i is less than argc, i plus plus, (3419.5400390625):  let me go ahead and do this. (3421.4600830078125):  I'm going to go ahead and just for the sake of discussion, (3423.820068359375):  let me print out where we're going with this. (3426.380126953125):  Let me go ahead and print out percent s backslash n, whatever (3430.7000732421875):  is in argv bracket i. (3433.5400390625):  So I'm not doing anything interesting yet, (3435.5001220703125):  but let's just demonstrate where we're going with this. (3437.800048828125):  Let me go ahead and make list dot slash list. (3440.880126953125):  And let me put the numbers 1, 2, and 3 as command line arguments. (3444.5400390625):  Enter. (3445.4200439453125):  There, we just have those numbers spit out. (3447.2200927734375):  I'm just kind of jumping through this hoop (3448.9200439453125):  to demonstrate how I'm getting those values. (3450.9801025390625):  But notice, the values in argv are always strings, aka char star. (3455.9400634765625):  So if I actually want to convert a string to an integer like this, (3461.64013671875):  how can I do this? (3463.06005859375):  I want to set the number variable equal to argv bracket i, (3467.820068359375):  but argv bracket i is a string. (3469.1600341796875):  How can I convert a string to a number? (3472.2401123046875):  Anyone recall? (3474.0400390625):  Yeah, a to i, so ascii to i, so ascii to integer. (3479.0400390625):  So if I do a to i, I can actually convert one to the other in this way. (3484.64013671875):  And now I can actually print this as an int instead of a string. (3488.4000244140625):  Now, that's not going to change the aesthetics of the program (3490.9000244140625):  if I print it out again, but it does, in fact, give me an integer to work with. (3495.0400390625):  But let's not bother printing it. (3496.4801025390625):  Let's instead put this number and any other number at the command line (3500.7200927734375):  into a linked list. (3502.4801025390625):  So let me go ahead and allocate a pointer called n. (3506.780029296875):  Let me set it equal to the return value of malloc, (3510.1600341796875):  asking malloc for the size of one node. (3513.800048828125):  Ideally, that will give me a chunk of memory (3516.0400390625):  that can fit this number and a pointer. (3518.56005859375):  Just for good measure, I'm going to check. (3520.360107421875):  Well, if n equals equals null, then actually this isn't going to work. (3525.5001220703125):  So we should probably, you know, free memory thus far. (3529.10009765625):  So I'm just going to leave this like this, (3530.860107421875):  because there's a few steps involved. (3532.5001220703125):  So free memory thus far. (3535.5400390625):  And then we can go ahead, for instance, and return 1. (3539.340087890625):  All right, if now I don't have an error, and if I don't have an error, (3545.1800537109375):  then I'm going to return 1. (3547.340087890625):  So if I don't have an error, then I'm going to return 1. (3551.0201416015625):  is not, in fact, null, but it's a valid address. (3553.1401414871216):  I can go into n. (3554.580141544342):  I can follow that pointer to the number field (3557.1401414871216):  and set it equal to the actual number. (3559.3401412963867):  So this is a little strange at first glance (3561.3801412582397):  that I've got number on the left and number on the right, (3563.1001415252686):  but they're different. (3564.2201414108276):  n is currently pointing at a chunk of memory big enough to fit a node. (3569.3401412963867):  n arrow number means go to that chunk of memory (3571.980140686035):  and go to the top half of the rectangle and update (3575.420141220093):  that number to be whatever the human typed in after we've (3578.900140762329):  converted it on line 16 here to an actual integer. (3584.06014251709):  All right, what next do I do? (3586.0201416015625):  n arrow next should probably be at this point initialized to null. (3591.7401428222656):  And how now do I actually add this node n to my original linked list? (3597.220142364502):  Well, I could just do list equals n, and that (3599.7401428222656):  would update, a la the foam finger, my list variable (3603.1801414489746):  to point at this new node. (3604.980140686035):  But we said before that that's potentially bad. (3607.3401412963867):  Why? (3608.2601432800293):  Because if list is already pointing at something, (3611.3001403808594):  we can't just blindly change what it's pointing at, (3613.4601402282715):  because we'll have orphaned any previous numbers. (3615.780143737793):  It's not relevant at the moment, because we're still (3617.940139770508):  in the first iteration of this loop, but we don't (3620.3401412963867):  want to orphan or leak any memory. (3622.7001419067383):  So what do I first want to do? (3624.260139465332):  Before I actually point the linked list at that new node, (3627.8201446533203):  I'm going to instead say, go to this current node, arrow, next, (3633.4201431274414):  and actually set that equal to list. (3635.7401428222656):  So strictly speaking, I don't actually need to initialize it to null. (3639.500144958496):  I can initialize the next field of this new node (3643.1401443481445):  to point at the existing list. (3646.3001403808594):  So what I'm going to do here is instead of initializing the next field (3649.3401412963867):  equal to null, if I want to insert this new node in front of any nodes that (3654.180145263672):  already exist, I can simply say, set the node's next field (3659.780143737793):  equal to whatever the list currently is. (3661.9601440429688):  And now, in this last line, I can update the list itself to point to n. (3666.3201446533203):  So after this, let's just go ahead and do something relatively simple, (3669.8001403808594):  even though the syntax for this is going to look a little complicated at first. (3673.0801391601562):  How do I go about printing the whole list? (3676.2401428222656):  So print whole list. (3678.480140686035):  Well, there's a couple of ways to do this. (3680.2401428222656):  But if you imagine a world, if we fast forward (3682.2001342773438):  to a world in which we now have a linked list of size 3, for instance, (3686.4801483154297):  here's where we might be at some point in the computer's memory. (3689.7601470947266):  We've inserted the 1, then we inserted the 2, then we inserted the 3. (3693.3201446533203):  But because we're prepending everything, it actually looks like 3, 2, 1. (3697.0801391601562):  So how could I go about printing this? (3699.0401458740234):  Well, ideally, I could do this. (3700.880142211914):  If a computer can only look at one location at a time, (3703.4601440429688):  I can sort of grab my foam finger and point at the 3 and print it out, (3707.440139770508):  point at the 2 and print it out, point at the 1 and print it out. (3710.880142211914):  And then because this is null, I'm all done pointing and printing. (3714.360137939453):  But how can I translate this to actual code? (3716.9601440429688):  Well, I could implement that foam finger, so to speak, in the following way. (3720.680145263672):  I could give myself a pointer, often abbreviated by computer scientists (3724.120147705078):  as PTR, specify that that's indeed a pointer to a node as per that star, (3730.0001373291016):  and initialize that pointer to be the list itself. (3732.7601470947266):  So this is the code equivalent of, if I have this same picture on the screen, (3737.2401428222656):  declaring a pointer variable and point it at whatever (3740.5601348876953):  the list itself is storing first. (3744.680145263672):  And now that's akin to doing this. (3747.880142211914):  If I now go back into my code, how can I do this? (3751.5201416015625):  Well, so long as that pointer does not equal null, (3754.7601470947266):  that is, so long as that pointer is not at the end of the list, (3757.8401489257812):  let me go ahead and print out, using printf, an integer with %i. (3764.2601470947266):  And then let's print out whatever I'm currently pointing at in PTR, (3768.600143432617):  arrow number. (3770.0001373291016):  So whatever I'm pointing at, go there and print the number that you find. (3775.0001373291016):  After that, what do I want to go ahead and do? (3777.160140991211):  I'm going to set pointer equal to pointer arrow next. (3781.8001403808594):  So what does this mean? (3782.8001403808594):  If I go back to my picture here and I want to actually walk through this (3787.100143432617):  thing, that first line of code ensures that this foam finger, aka PTR, (3792.0001373291016):  represented here, is pointing at the first element of the list. (3795.2001342773438):  Once I've printed it out with printf, I'm then (3797.5201416015625):  doing pointer equals pointer next, which is like following this next arrow. (3803.2001342773438):  So PTR now points at the 2. (3806.0001373291016):  I then print that out and set pointer equal to pointer next. (3808.7601318359375):  That's like following this arrow and updating the pointer (3811.5201416015625):  to point at this node instead. (3813.2001342773438):  At that point, the next step is going to be to point it to null. (3816.2801513671875):  So for all intents and purposes, I'm done. (3818.7401428222656):  And that's why we can actually get away with this while loop, (3822.440155029297):  because while pointer is not null, it's going to print and print (3827.380126953125):  and print. (3828.2801513671875):  Now, let me go into my terminal window. (3830.64013671875):  Let me go ahead and make a list and really hope I didn't make any mistakes, (3833.8401489257812):  because this is a lot all at once. (3835.64013671875):  Seems to have compiled OK. (3837.360137939453):  When I run .slash list of 1, 2, 3, theoretically, this code, if correct, (3842.64013671875):  should, unbeknownst to me, build up an entire linked list in memory. (3846.2401428222656):  But what's it going to print out ultimately? (3850.4801330566406):  What do you think it's going to print? (3852.0801391601562):  Yeah. (3852.5801391601562):  AUDIENCE MEMBER 2, 3, 4. (3853.920135498047):  Could print out null, if I really screwed up, yes. (3857.4801330566406):  What else? (3859.400146484375):  Or it could print out 3, 2, 1. (3860.7601318359375):  And frankly, that's what I'm hoping for. (3862.4801330566406):  So even though I've given it in argv 1, 2, 3, (3867.2001342773438):  because I'm pre-pending to the beginning of the list, the beginning (3869.9601440429688):  of the list, beginning of the list each time, (3871.880126953125):  I think, indeed, we're going to see 3, 2, 1. (3875.2801513671875):  Now, that's fine. (3876.2001342773438):  That's correct. (3877.16015625):  But it's not necessarily what we might want. (3880.64013671875):  So how could we actually go about inserting things maybe otherwise? (3885.0001525878906):  Because, in fact, if we consider this algorithm, (3887.7201538085938):  what's the running time of insert? (3890.8401489257812):  How many steps are required right now, given a linked list of size n, (3894.0001525878906):  if you want to go ahead and insert one more node? (3896.0401306152344):  There's actually a reason I took this lazy approach of pre-pending, (3899.2801513671875):  pre-pending. (3900.680145263672):  In big O notation, how much does it cost us to insert into a linked list? (3908.9601440429688):  Think about it this way. (3910.0001525878906):  Does it matter how many nodes are already in the linked list, (3913.120147705078):  whether it's 1, or 2, or 3, or 300, or 3,000? (3916.64013671875):  If you're pre-pending, it doesn't matter how long that chain is. (3920.120147705078):  You're just constantly putting it in the beginning, (3922.2001342773438):  at the beginning, at the beginning. (3923.680145263672):  Now, how many steps is this? (3924.7201538085938):  I don't know exactly. (3925.5201416015625):  I'd have to count the lines of code. (3926.64013671875):  But it's some small number. (3928.0801391601562):  It's like two steps, three steps. (3929.400146484375):  How many lines of code is it? (3930.680145263672):  It's very few, to pre-pend, pre-pend. (3933.600128173828):  So I would dare say that the running time of insertion into a linked list (3940.0801391601562):  is actually constant time. (3941.440155029297):  It's big O of 1. (3942.2001342773438):  And that's super fast, because it doesn't matter how big the list is. (3944.9601440429688):  Boom, boom, boom. (3945.8001403808594):  You've pre-pended to the list. (3947.880126953125):  But there's a flip side. (3949.2001342773438):  What's the running time of searching a linked list, (3951.4801330566406):  looking for something in it, finding a number in it? (3956.2401428222656):  Well, if it looks like this, how long does (3958.2401428222656):  it take you to find some arbitrary number that the human might ask you for? (3962.2001342773438):  Like, how many steps will it take to find me the number 1 if it's there? (3965.5201416015625):  So N, big O of N. Because in the worst case, (3967.64013671875):  the number you're looking for might be all the way at the end. (3970.2401428222656):  And even though you and I, again, have this bird's eye view (3972.5601501464844):  and we can obviously see where the 1 is, the only way we can get to the 1 (3975.8001403808594):  is by starting at the 2. (3977.3201293945312):  How do you get to the 2? (3978.440155029297):  You've got to start at the 3. (3979.600128173828):  How do you get to the 3? (3980.600128173828):  You've got to start at the beginning of the list itself. (3983.5601501464844):  And so whereas in the world of arrays, where (3985.5601501464844):  you had this contiguous chunk of memory, just (3987.5201416015625):  like we had lockers on the stage weeks ago, (3989.440155029297):  and you could jump to the middle, and then the middle of the middle, (3992.3201293945312):  and the middle of the middle, that was all predicated on contiguousness. (3995.5201416015625):  Why? (3996.120147705078):  Because if you know where the first locker was, (3999.2001342773438):  and you know where the last locker was, you can subtract one from the other, (4002.600128173828):  divide by 2, and boom, you get the index or the location numerically (4006.2801513671875):  of the middle locker. (4007.4801330566406):  And you can do that again and again. (4009.2401428222656):  I cannot do any such math here. (4011.8401489257812):  The middle of this linked list is obviously here. (4014.440155029297):  But it doesn't matter what the location of this one is in memory. (4017.600128173828):  It doesn't matter what the location of this (4019.360137939453):  is in memory, because they could be anywhere in the computer's memory. (4022.0801391601562):  So you can subtract one from the other, divide by 2, (4024.680145263672):  and that's going to put you in some random location, (4027.3201293945312):  because these chunks of memory are not back to back to back to back. (4030.9601440429688):  They're every which way. (4032.600128173828):  So this is to say, what algorithm from week 0 can we not use on linked lists? (4038.0801391601562):  So binary search. (4039.16015625):  So that very algorithm we started the class with (4042.0801391601562):  was all predicated on contiguous chunks of memory, like an array. (4045.680145263672):  The problem with an array, though, of course, (4047.5601501464844):  though, is that you paint yourself into this corner, (4049.8001403808594):  and you have to know in advance how many locations you want. (4053.2401428222656):  And if you round up, you're wasting space. (4055.0001525878906):  If you round down, you're wasting time. (4056.600128173828):  So you're sort of screwed either way. (4058.2401428222656):  A linked list avoids those problems. (4059.9601440429688):  It's more of a dynamic data structure that can grow. (4062.440155029297):  And frankly, if we code it up, it could even shrink. (4064.64013671875):  We could remove these nodes back and forth. (4067.1201171875):  And so we're not necessarily wasting time on insertion, (4071.5601196289062):  but we are on searching this thing. (4073.8001708984375):  We're back to big O of n when it comes to searching a linked list, (4077.3601684570312):  as opposed to it being log n, which was much, much better. (4081.6801147460938):  So the upside of prepending nodes in this way (4084.3601684570312):  is that we have constant time insertion of new nodes, (4086.7601318359375):  because we just continually insert, insert, insert (4088.8001708984375):  into the very beginning of the list. (4090.5201416015625):  Of course, a side effect of this is that the numbers might end up (4093.8001708984375):  in completely reverse order, as they have here, because I first inserted 1, (4097.960144042969):  but then I prepended 2, and then I prepended 3. (4100.8001708984375):  Well, we could perhaps take a completely different approach (4103.360168457031):  and append the nodes upon insertion instead. (4106.100158691406):  So for instance, if I start off with an empty list, I could then insert 1. (4109.5001220703125):  I can insert 2, and I can insert 3. (4111.6201171875):  And in this case, I actually get a bit lucky (4113.5001220703125):  that now they are, in fact, in sorted order. (4115.700134277344):  Now, to be fair, that's not guaranteed, but let's at least (4118.180114746094):  consider what the code would look like if we (4120.380126953125):  were to take this alternative approach of appending nodes instead of prepending. (4124.380126953125):  Well, rather than write out the code from scratch, (4126.460144042969):  let me open up a pre-made version of list.c that even has some comments (4130.6201171875):  to explain what's going on. (4132.14013671875):  Some of this code is pretty much the same, (4134.3001708984375):  but allow me to scroll down roughly to the middle, where we'll (4137.940124511719):  see the actual logic in question. (4140.5401611328125):  So first, on line 35 here, we're checking if the list is null, (4144.100158691406):  because if there's no list yet, it's actually pretty easy to prepend (4147.14013671875):  or append. (4148.180114746094):  We're just going to go ahead and update the list variable (4150.900146484375):  to point to this new node n. (4153.420166015625):  But if the list isn't empty, and there's at least one node there already, (4156.700134277344):  well, then what we're going to do is this in line 45. (4159.580139160156):  We're going to iterate over that existing linked list. (4163.060119628906):  And I'm going to do so with a temporary variable called pointer, (4166.2601318359375):  or PTR for short, that's initialized to the beginning of the list, (4169.5001220703125):  sort of a foam finger pointing at that first node initially. (4172.580139160156):  I'm going to, on every iteration, update that pointer variable (4175.980163574219):  to point to the next node, to the next node, (4178.860168457031):  sort of pointing one node ahead with that foam finger. (4181.380126953125):  But on each iteration, I'm also going to make sure (4183.580139160156):  that the pointer variable is not null, because if it is null, (4186.5401611328125):  that means I'm sort of pointing past the end of the list, (4188.980163574219):  or that is the list has ended. (4191.5401611328125):  But if inside of that loop, I notice that the current node's next field is (4197.66015625):  null, I actually know logically that I'm at the end of the list (4200.980163574219):  without going past it. (4202.580139160156):  So at that point, if my goal is to append this new node, (4205.460144042969):  I'm going to go ahead and set pointer arrow next, which is currently null, (4209.700134277344):  but set it equal to the address of this new node, (4212.860168457031):  effectively appending that node to the end of the list. (4215.940124511719):  So for instance, if we started with a list of 1 and 2, what we've just done (4220.14013671875):  is updated 2's next field to be equal to the address of the node containing 3. (4226.460144042969):  Meanwhile, the node containing 3's next field (4228.66015625):  is null by default, because it is now the new end of the list. (4233.460144042969):  Now, what are the implications for maybe performance or efficiency now? (4237.5001220703125):  Well, we are now appending to the list, which (4240.3001708984375):  means we're no longer gaining constant time of insertion, right? (4244.7801513671875):  Because any time we prepended, it took us some finite number of steps. (4248.3001708984375):  We just had to update a couple of pointers (4250.2601318359375):  at the beginning of the list, the beginning of the list. (4252.14013671875):  And it doesn't actually matter how much longer the list is getting, (4254.900146484375):  because we're never traversing the list when we're prepending. (4257.820129394531):  But when we're appending, by definition, we're finding the end of the list, (4260.940124511719):  finding the end of the list, finding the end of the list. (4263.2801513671875):  And so our running time now for insertion (4265.180114746094):  is no longer big O of 1 or constant time. (4267.5401611328125):  It's now big O of n, because if there's n nodes in the list already, (4270.940124511719):  just to find the end of it, we need to actually traverse the whole list (4274.380126953125):  to actually find where this new node should go. (4277.14013671875):  But even so, we've gotten lucky in this appending case (4280.5001220703125):  that we inserted 1, then 2, then 3. (4282.580139160156):  That's just because of my choice of inputs. (4284.420166015625):  Suppose that we don't know in advance what the inputs are going to be. (4287.580139160156):  They might be large numbers, small numbers, or anything in between. (4290.980163574219):  But they might not necessarily be in order. (4293.340148925781):  But if we want to maintain this linked list in sorted order, (4296.380126953125):  I think our logic's actually going to have to change. (4299.700134277344):  So let me actually go ahead and open up a new version of my linked list code, (4305.340148925781):  this one to main in advance. (4307.340148925781):  And in this version of my code, as we'll soon see, (4310.420166015625):  I've gone about changing the logic just a little bit (4314.220153808594):  so that I can actually now handle this additional case. (4318.2601318359375):  Because when inserting nodes in arbitrary order, (4321.380126953125):  if I wanted them to end up being sorted, I (4323.980163574219):  have to consider a few possible scenarios. (4325.7401123046875):  Maybe there's no list whatsoever. (4327.580139160156):  So let's actually look for that. (4329.0201416015625):  Let me scroll down in this final version of my linked list code. (4332.0201416015625):  And actually, that case here on line 35 is pretty much the same. (4335.7401123046875):  If there's no list there and the list variable is null, (4338.3001708984375):  well, let's just update it to point to this new node. (4340.6201171875):  But things get more interesting when there is at least one node there. (4344.900146484375):  Because if the goal is to maintain sorted order, (4347.0201416015625):  we now need to decide, does this new node, whatever its number is, (4350.980163574219):  go before the beginning of the list, at the end of the list, (4354.5401611328125):  in the middle somewhere of the list? (4356.460144042969):  So let's break that down. (4358.2601318359375):  If we find that the new node's number is less than the list's number here, (4364.7801513671875):  well, then it belongs at the beginning of the list (4367.180114746094):  because it's smaller than any of the numbers already there. (4369.7801513671875):  So what I'm going to go ahead and do is update this new node's next field (4373.700134277344):  to point at the current linked list. (4376.220153808594):  And then I'm going to update the linked list variable (4378.420166015625):  to equal the address of this new node. (4380.820129394531):  The effect then is, no matter how long the existing list is, (4384.340148925781):  if this new node's number is smaller than everything else in the list, (4388.060119628906):  I want to just kind of splice it in at the beginning. (4390.420166015625):  So that's actually pretty straightforward with just a couple (4392.960144042969):  of pointer updates. (4394.5401611328125):  But the other scenario is that it doesn't just (4396.580139160156):  belong at the very beginning of the list. (4398.2401123046875):  It's somewhere else in the list. (4399.5401611328125):  And that itself is two scenarios. (4401.1201171875):  Maybe it's in the middle of the list. (4402.66015625):  Maybe it's at the very end of the list. (4404.320129394531):  So let's consider those scenarios as well. (4406.820129394531):  Let me scroll down here. (4407.980163574219):  And in my else clause, it's a bit bigger this time. (4410.14013671875):  Why? (4410.7801513671875):  Because on line 51 in this case, I'm going (4413.460144042969):  to induce another for loop as before. (4416.180114746094):  But this time, I'm trying to determine if this node belongs (4418.940124511719):  at the end or somewhere in the middle. (4421.220153808594):  So I'm not just looking for the end this time. (4423.3001708984375):  I'm actually comparing the value, the integer, inside of this new node (4427.340148925781):  against what is currently in the list. (4429.6201171875):  So for instance, if logically, I actually (4432.3001708984375):  find my way all the way to the end of the list, (4434.7401123046875):  whereby the next field in the pointer variables node equals null, (4439.820129394531):  well, then logically, I didn't find an earlier spot for this node. (4442.940124511719):  So let me go ahead and update that pointer's next field (4446.580139160156):  to equal the address of this new node. (4448.560119628906):  And then like before, let's just break out because I'm done. (4451.100158691406):  I somehow mathematically got all the way to the end of the list (4453.900146484375):  because there is that null pointer. (4455.900146484375):  So it must be the case logically here that this new node belongs at the end. (4460.0201416015625):  But this is the juicier, slightly more challenging one. (4463.5001220703125):  But it's what ensures that we can maintain sorted order, (4465.820129394531):  even if the new node belongs somewhere in the middle. (4468.380126953125):  So down here on line 62, I'm going to ask this question. (4472.380126953125):  If the new node's number is less than the number in the next node, (4479.14013671875):  that is to say, if my foam finger is pointing here, (4481.580139160156):  but the number I'm trying to insert is smaller than the next node over there (4486.6201171875):  and implicitly the same as or greater than the current node's number, well, (4491.5401611328125):  then I'm going to go ahead and do this. (4493.3001708984375):  I'm going to update the new node's next pointer (4496.460144042969):  to be equal to whatever the current node I'm pointing at's next pointer, (4500.980163574219):  so that I can then update that pointer's next field to equal the new node. (4507.060119628906):  And then I can break out all together, doing a similar splice (4511.340148925781):  in the middle of this list, but manipulating a node effectively (4515.100158691406):  to the left and the right to make room for this new node. (4518.6201171875):  So collectively, what does this code do? (4520.66015625):  Well, if we start out with that initially empty list (4523.3001708984375):  and maybe we insert the number 2, it just goes right there. (4526.3001708984375):  But suppose that we insert next the number 1, which of course is smaller. (4529.7801513671875):  This code now ensures that the 1 is going (4531.700134277344):  to get inserted at the beginning of the list. (4533.900146484375):  If we then insert the number 4, well, that's bigger than 1 and bigger than 2, (4537.420166015625):  so it logically is going to end up at the end of the list. (4540.5401611328125):  And lastly, in this example, if we insert 3, which again is initially (4544.0201416015625):  out of order, this code can ensure that we still insert it in sorted order, (4548.7401123046875):  because it's going to end up in between nodes 2 and 4. (4552.420166015625):  So here, too, in terms of running time, insertion is still big O of n. (4556.5001220703125):  It's not quite as bad in practice as always adding it to the end of the list, (4559.940124511719):  the end of the list as was the case when we blindly appended new nodes. (4563.900146484375):  But it is going to be in big O of n, because in the worst case (4566.460144042969):  here, if we've got n nodes in the list already, then in the worst case, (4570.420166015625):  it might indeed be such a big number that it belongs at the end of the list. (4575.380126953125):  All right, that was a lot. (4576.5401611328125):  Let's go ahead and take a delicious cookie break here, (4578.9801025390625):  and we'll be back in 10. (4581.420166015625):  All right, we are back. (4583.5001220703125):  And to recap, the problems we've solved and the problems we've created (4587.7001953125):  are arrays were problematic, because they were a fixed size, (4590.940185546875):  and that can get us into trouble. (4592.340087890625):  Or it causes us to waste more space preemptively, (4596.18017578125):  even though we might not ever use it. (4597.860107421875):  So we introduced linked lists again to solve that problem by being more (4602.14013671875):  dynamic and only allocate as much memory as we need on demand step by step. (4606.14013671875):  But of course, we're spending extra space for the pointers. (4609.14013671875):  We might gain performance if we at least prepend all of our elements to it. (4613.18017578125):  But we lose time again if we append or insert in sorted order. (4617.380126953125):  So it's not clear, frankly, I think, to me in even hearing these upsides (4620.9801025390625):  and downsides if there's a clear win. (4622.860107421875):  But maybe there's a way to get the best of both worlds (4626.0601806640625):  by trying to capture the upsides of having information that (4630.340087890625):  is kept in sorted order, that allows us to maybe divide and conquer still, (4635.340087890625):  but still gives us the dynamism to grow or shrink the data structure. (4639.2200927734375):  And thus, we're born trees. (4641.10009765625):  So what we're about to explore are variants of these ideas of arrays (4645.9801025390625):  and linked lists and see if we can maybe kind of mash up (4648.66015625):  some of those building blocks and create more interesting, more (4652.860107421875):  compelling solutions that are even not just one dimensional, (4656.10009765625):  sort of left to right, but are maybe two dimensional (4658.7801513671875):  and sort of have different axes to them or dimensions. (4661.940185546875):  So a tree in the real world, of course, tends (4664.14013671875):  to grow up from the ground like this. (4665.880126953125):  But it tends to branch out. (4667.5802001953125):  And branches branch. (4668.9801025390625):  And that might already, in your mind's eye, (4671.14013671875):  evoke notions of forks in the road or conditionals, as we've seen. (4675.7801513671875):  And let me propose that we first consider (4677.6201171875):  what the world calls binary search trees. (4680.10009765625):  And so bi is back in that we can do things in half and half and half (4683.18017578125):  somehow if maybe we think about arrays a little bit more cleverly. (4686.860107421875):  So here's an array of size 7. (4688.5601806640625):  And I chose that deliberately because there's a perfect middle. (4691.2200927734375):  There's a middle of middle and so forth, just like the lockers a few weeks back. (4694.5802001953125):  So in the world of arrays, this was actually pretty efficient (4698.2200927734375):  because we can do binary search. (4699.7001953125):  And middle of middle, middle of middle of middle, and so forth. (4702.380126953125):  And that gave us logarithmic running time. (4704.860107421875):  But it's only size 7. (4706.5802001953125):  And we concluded that it's going to be like big O of n headache (4709.5001220703125):  to copy this into a slightly bigger array, free the old memory, (4712.6201171875):  and so forth. (4713.1201171875):  And thus were born linked lists. (4714.60009765625):  But with linked lists, we lost log of n running time. (4718.66015625):  Why? (4719.2200927734375):  Because we have to always start at the beginning (4721.340087890625):  to get, for instance, to the middle or to the end of the list in the worst (4724.6201171875):  case. (4725.340087890625):  But what if we start to think a little more cleverly in multiple dimensions? (4728.340087890625):  So just for the sake of discussion, let me highlight the middle. (4732.0601806640625):  of this here array, let me highlight the middle of the middle, (4735.0601806640625):  and then the middle of the middle of the middle. (4737.0601806640625):  So there's sort of implicit structure here. (4739.500180721283):  There's a pattern of sorts. (4740.700181007385):  And in fact, just to make this more obvious, (4743.0201807022095):  let me not treat this in as one dimension, left to right, but how about two, (4746.820180892944):  and give myself a bit of vertical space? (4748.50018119812):  So it's the exact same array, but allow me to just think about it now (4751.860179901123):  as though the middle elements way up here, the middle of the middles (4754.360179901123):  are slightly lower, and the middle of the middle of the middles, (4757.020179748535):  or the leaves really, are at the bottom of this tree. (4759.180181503296):  And that word's deliberate. (4760.340181350708):  We actually borrow vernacular from the world of trees, (4762.620180130005):  where the leaf nodes, or leaves, are the ones at the very bottom, (4767.340179443359):  and the root node is the one at the very top. (4770.10018157959):  So for the sake of discussion, computer scientists (4772.180179595947):  draw trees like this instead of like this, but it's the exact same idea. (4776.380180358887):  They just tend to grow down in discussions, (4779.420181274414):  more like a family tree if you drew those growing up, for instance. (4783.300182342529):  So what's interesting here? (4785.90018081665):  Well, at the moment, we've sort of broken the array model, (4789.020179748535):  because this memory is absolutely not contiguous, (4791.220180511475):  because this number's here, this number's here, here, here, and here. (4794.140182495117):  It's all over the place. (4795.180179595947):  But we do have pointers now in our toolkit, (4797.86018371582):  whereby even if these numbers are anywhere in the computer's memory, (4801.220184326172):  we can kind of stitch them together, like we did string and those balloons. (4805.10018157959):  Now, it's not sufficient just to have one piece of string (4807.620178222656):  for each node, or one pointer, but what if we actually (4810.660179138184):  give each of these nodes not just a number, like the number four, (4813.9401779174805):  the number two, the number six, let's give them each a number and two (4816.900177001953):  pointers, a so-called left child and a right child, so to speak. (4821.9401779174805):  So we could do this. (4823.0601806640625):  And I'm going to abstract away now. (4824.5601806640625):  Technically, they're not even rectangles anymore. (4827.020179748535):  They're really long rectangles, or they're (4829.020179748535):  like sort of upside-down Ts that have three boxes to them. (4832.460182189941):  But I'm just going to abstract away nodes now as just simple squares, (4836.020179748535):  and it's an implementation detail as to what the structs actually are. (4839.500183105469):  But the arrows suggest that each of these nodes now has two pointers. (4844.140182495117):  You don't have to use them. (4845.260177612305):  The leaf nodes have nothing to point to, so those can all be null, probably. (4849.10018157959):  But each of these nodes now has two pointers. (4852.620178222656):  Now, what's the implication of this? (4854.380180358887):  This here is what we call a binary search tree, because one, (4858.300178527832):  and first and foremost, it's obviously a tree. (4860.780181884766):  But it also is a data structure that's kept in sorted order, (4865.0601806640625):  whereby notice what is true. (4866.460174560547):  If you pick any node in this tree, like the number four, (4869.500183105469):  everything to the left of it, its left subtree, so to speak, is smaller. (4874.260177612305):  Everything to the right of it, its right subtree, is larger. (4877.660186767578):  And that's true elsewhere. (4878.740173339844):  Look at the six. (4879.420181274414):  Everything to the left is smaller. (4881.100173950195):  Everything to the right is bigger. (4882.660186767578):  And same thing over here. (4884.820175170898):  So in some sense, this is a recursive data structure, (4887.580184936523):  because you can say the same thing about each of these nodes, (4890.740173339844):  because each of these subtrees compose a larger tree. (4894.620178222656):  Or conversely, this big tree is a composition of one, two subtrees, (4899.260177612305):  plus one more node. (4900.540176391602):  So think back to our Mario example on those bricks. (4902.740173339844):  Well, what's a pyramid of height four? (4904.540176391602):  Well, it's just a pyramid of height three plus one more row. (4907.0601806640625):  What's a tree of height three? (4908.780181884766):  Well, it's two subtrees of height two plus one more row, or really, (4913.02018737793):  one new root node to connect them. (4915.380187988281):  So this already is sort of a recursive data structure by that logic. (4918.540176391602):  How do we translate this into code? (4920.02018737793):  Well, we won't sludge through so much low-level C code this time around. (4923.380187988281):  But let me propose that we could implement a node now (4926.500183105469):  as being similar in spirit to what we did last time, (4929.140182495117):  where every node used to have a number and a next pointer. (4932.380187988281):  But now, let's actually make some room for ourselves and redefine a node (4935.500183105469):  as still having a number, but now having two pointers. (4939.540176391602):  And I'll call them, obviously, left and right, (4941.86018371582):  though we could call them anything we want. (4943.700180053711):  I could call it next and previous, but really, left and right (4946.240173339844):  would seem to make more sense with children of a given node like this. (4950.300186157227):  So this in C is how we might implement, therefore, (4953.460174560547):  a node in a binary search tree. (4956.18017578125):  And so let's consider pictorially what the running (4958.500183105469):  time is of searching for something. (4959.940185546875):  If this here is the tree and it follows that binary search tree definition (4963.820175170898):  where everything to the left is smaller, everything to the right is bigger, (4967.420181274414):  well, how many steps might it take if you have n nodes in a tree like this? (4972.460174560547):  Well, it's not going to take me n steps, because I certainly (4975.300186157227):  don't have to look through every node. (4977.0601806640625):  And in fact, just like a linked list starts on the left-hand side, (4980.220184326172):  so to speak, that's just an artist's rendition, (4982.18017578125):  just as a linked list starts on one end and you (4984.780181884766):  have to traverse the whole thing, a tree, because it's two-dimensional, (4987.940185546875):  always starts in memory at the root node. (4990.380187988281):  So this is always where you start any operation, insertion, deletion, (4993.940185546875):  searching. (4994.900177001953):  So by that logic, in the worst case, if there's n nodes here, (4998.420166015625):  how many steps would it seem to take? (5001.0601806640625):  It's not big O of n, but so it's actually back to big O of log n. (5006.020172119141):  Why? (5006.740173339844):  Because actually, if you kind of think of the height, (5008.400177001953):  there's roughly eight nodes in here. (5010.020172119141):  And log base 2 of 8 is actually 3. (5011.8201904296875):  And so 1, 2, 3 is the height of this tree. (5014.380187988281):  So in the worst case at the moment, it seems (5016.860168457031):  that it's only going to take me like one node, two nodes, three nodes, (5019.900177001953):  or really just two steps to get to the very bottom of this tree (5022.900177001953):  to decide is a number there or not. (5025.900177001953):  I certainly can ignore this entire subtree. (5028.8201904296875):  Why? (5029.260192871094):  Because I'm searching for the number 7, just like the phone book from week 0, (5032.900177001953):  I can kind of divide and conquer this problem. (5035.040191650391):  If I'm looking for 7, I don't need to bother wasting any time (5038.420166015625):  looking at this entire subtree, which is almost 50% of the picture (5043.260192871094):  on the screen. (5044.340179443359):  And so I can focus on this half, then this half, (5046.780181884766):  and boom, I'm done. (5048.580169677734):  So we sort of have binary search back. (5050.780181884766):  We have the metaphor of the locker's back by operating now in two dimensions (5054.940185546875):  to mitigate the reality that our memory is no longer contiguous, (5058.380187988281):  but that's fine. (5059.380187988281):  We can follow these arrows. (5060.7001953125):  We can use these pointers instead to get anywhere that we actually want. (5065.860168457031):  So any questions now on trees, or specifically binary search trees, (5069.7001953125):  which I dare say are sort of like the best of both worlds. (5072.120178222656):  All of the upsides of an array, and it's like log n running time, (5075.340179443359):  and all of the upsides of the dynamism of linked lists, (5077.7001953125):  because this thing can grow and shrink and doesn't need to be contiguous. (5083.220184326172):  Any questions on this? (5086.0601806640625):  All right, well, the code, too, lends itself to relative simplicity. (5090.460174560547):  And here's where recursion applies not just to the structure of the data, (5094.340179443359):  but also the code itself. (5095.500183105469):  So just for the sake of discussion, we won't run this kind of code. (5098.220184326172):  We'll just look at it on screen here. (5099.780181884766):  Suppose you're implementing a function called search, (5102.100189208984):  whose purpose in life is to search a tree and return true or false. (5105.3001708984375):  I found the number you're looking for. (5107.0601806640625):  Well, here's the number I'm looking for. (5108.760192871094):  It's one of the arguments. (5109.940185546875):  And the first argument, more importantly, (5111.980194091797):  is actually a pointer to the tree itself, a pointer to the root of the tree. (5116.140167236328):  And that's all the information we need to search a tree (5118.500183105469):  and go left, go right, go left, go right. (5120.18017578125):  How? (5120.780181884766):  Well, let me do this. (5121.8201904296875):  As always, we'll have a base case when it comes to recursion. (5124.940185546875):  Because if there's no tree there, then it (5126.860168457031):  makes no sense to even ask me this question. (5128.500183105469):  I'm just going to return false. (5129.780181884766):  If you hand me null, there's nothing to do. (5131.580169677734):  Return false. (5132.860168457031):  But suppose that you don't hand me null. (5135.340179443359):  And suppose that the number I'm looking for (5137.500183105469):  is less than the number in the tree at the moment, the number at that root. (5141.940185546875):  Well, what do I want to do? (5143.0601806640625):  I effectively want to go left. (5144.620178222656):  I want to search the left subtree. (5146.100189208984):  How do I do that? (5147.260192871094):  I'm going to return the recursive return value from the same search (5152.3001708984375):  function, passing in a slightly smaller tree, a so-called subtree, (5156.580169677734):  but the same number. (5157.660186767578):  And this is where recursion is kind of beautiful. (5159.660186767578):  Like, look at the relative simplicity of this. (5162.140167236328):  If search exists, which it doesn't exist in its entirety yet, (5164.860168457031):  but we'll get there. (5165.940185546875):  If you want to search half of the tree, just go there. (5169.0601806640625):  So go to the root of the tree, follow the left child pointer, (5171.980194091797):  and pass that in. (5172.900177001953):  Because it's a tree. (5173.740173339844):  It's just a smaller tree, but pass in the same number. (5176.380187988281):  What if, though, it's a bigger number? (5178.140167236328):  So what if the number you're looking for is bigger (5180.220184326172):  than the number at the root of the tree? (5182.940185546875):  Well, then just search the right subtree instead. (5186.380187988281):  And now, logically, what's the fourth and final case? (5191.980194091797):  If it's equal, so I can express that as, if the number you're looking for (5195.7001953125):  equals equals the number in the tree, that is, the root of the tree, (5199.740173339844):  then I'm going to go ahead and return true. (5201.580169677734):  And you might remember from our days with Scratch, (5203.18017578125):  like, even this conditional is not necessary. (5204.7001953125):  I just did it to be explicit. (5205.980194091797):  We can tighten that up as just an else instead. (5209.3001708984375):  And that's it. (5210.340179443359):  And this is where, again, recursion finally (5212.420166015625):  is maybe a little more accessible, a little more obvious in its cleanliness. (5216.100189208984):  There's relatively little logic here. (5217.860168457031):  But what's important is that these recursive calls here and here (5221.740173339844):  are dividing and conquering the problem implicitly. (5224.500183105469):  Why? (5225.0601806640625):  Because it's solving the same problem. (5226.640167236328):  Search for a number, but it's doing it on just half of the tree (5229.860168457031):  or the other half of the tree. (5231.660186767578):  And because we have this base case here, even (5233.740173339844):  if you get all the way to the bottom of the tree (5235.620178222656):  and you try to go down the left child or you try to go down the right child, (5238.780181884766):  but those pointers are null, then you know (5240.780181884766):  you didn't find it because you would have returned true sooner (5243.740173339844):  if anything had been, in fact, equal. (5246.380187988281):  So that, then, is recursive code for searching a binary search tree, which (5250.18017578125):  is, again, just to connect the dots of what we introduced last time (5253.260192871094):  of actually doing things now recursively and revisiting (5256.7801513671875):  some of our own weak zero problems. (5258.900207519531):  But I'm kind of lying to you here, like, yes, this is a binary search tree, (5263.460205078125):  but it's not always as pretty as this. (5265.360168457031):  It's certainly not always seven elements, (5267.100158691406):  but it doesn't actually have to be as well balanced as this one here is. (5271.0601806640625):  In fact, suppose that we insert the following numbers into an empty list, (5275.420166015625):  starting with 2. (5276.260192871094):  I can plop the 2 right there. (5277.520202636719):  That's the current root of this tree. (5279.66015625):  Suppose, though, that I insert next the number, how about 1? (5283.5401611328125):  Well, it stands to reason that it should go now to the left. (5286.100158691406):  And so now this is the tree of size 2. (5288.980163574219):  Now I insert the number, say, 3. (5291.500183105469):  It, of course, can go there. (5292.980163574219):  So that makes perfect sense. (5294.18017578125):  And I just kind of got lucky. (5295.460205078125):  Because I inserted these numbers as 2, then 1, then 3, (5298.460205078125):  I very cleanly got a balanced tree that sort of weighted properly (5303.100158691406):  left and right. (5304.380187988281):  But what if you have a more perverse set of inputs, so to speak? (5307.66015625):  You're not lucky. (5308.740173339844):  And like a worst possible situation happens (5310.900207519531):  in terms of the order in which the human is inputting data (5313.500183105469):  into this data structure. (5314.740173339844):  What if the human inserts 1 first? (5316.220153808594):  OK, well, it goes as the root of the tree. (5318.420166015625):  But here's where things start to devolve. (5320.7001953125):  What if the human then inserts 2? (5322.740173339844):  OK, it goes there. (5323.7801513671875):  What if the human then inserts 3? (5325.3402099609375):  Well, according to our definition, it goes there. (5328.260192871094):  It looks like part of a tree because of how I've drawn it. (5331.220153808594):  But what is it really? (5333.500183105469):  If you kind of tilt your head, right? (5336.7801513671875):  It looks really just like a linked list. (5338.66015625):  And there really is no second dimension. (5340.8201904296875):  I've drawn it this way. (5341.900207519531):  But this, for all intents and purposes, is a linked list of size 3. (5344.900207519531):  Why? (5345.5401611328125):  Because there's no having. (5346.7001953125):  There's no actual choosing left or right. (5349.900207519531):  Now, this is fixable. (5351.020202636719):  How could you fix this? (5351.980163574219):  It's still the same numbers, 1, 2, 3. (5353.7801513671875):  And it does adhere to the binary search tree definition. (5357.3001708984375):  Every number to the right is greater. (5359.0601806640625):  Every number to the right is greater. (5360.620178222656):  Every number to the left is, well, it's inapplicable. (5362.8201904296875):  But it certainly doesn't violate that definition. (5365.140197753906):  Could you kind of fix this tree somehow and make it balanced (5369.380187988281):  so it's not devolving into big O of n, but it's still technically log of n? (5374.740173339844):  What should be the root? (5379.3001708984375):  So I could reverse the pointer from 1 to 2, yeah. (5382.5401611328125):  And so sort of pictorially, if I kind of take this (5384.940185546875):  and I just kind of like swing everything over and make 2 the new root, (5389.18017578125):  then indeed, this could be the new root up here. (5391.380187988281):  1 could be hanging off of it over here. (5393.7801513671875):  And 3 can be hanging off of the 2 as is. (5396.7001953125):  So long story short, when it comes to binary search trees, by themselves, (5400.980163574219):  they don't necessarily guarantee any sort of balance. (5403.420166015625):  So even though theoretically, yes, it's big O of log n, which is fantastic, (5407.460205078125):  not if you get a perverse set of inputs that just (5409.5401611328125):  happen to be, for instance, the worst possible scenario. (5412.260192871094):  Now, it is fixable. (5413.140197753906):  And in fact, in higher level courses in computer science, (5415.500183105469):  specifically on algorithms and data structures, (5417.7001953125):  you'll be introduced, if you go down that road, (5419.940185546875):  of how you can tweak the code for insertion and deletion (5424.66015625):  in a binary search tree to kind of make these fixes along the way. (5428.100158691406):  And it's going to cost you a few more steps to kind of fix things (5430.8201904296875):  when they get out of whack. (5431.940185546875):  But if you do it every insertion or every deletion, (5434.7801513671875):  at least you can maintain a balanced tree. (5437.400207519531):  And you'll learn about different types of balanced trees. (5439.8201904296875):  But for our purposes now, we don't necessarily get that property, (5442.940185546875):  even if we do want log n, unless you keep it balanced along the way. (5447.860168457031):  Now, what about other combinations of arrays and linked lists? (5451.66015625):  Like, we can really start to mash these things up (5453.620178222656):  and see what comes out of them. (5455.020202636719):  Dictionaries are another abstract data type, similar in spirit (5459.620178222656):  to stacks and queues, in that you can implement them in different ways. (5464.140197753906):  A dictionary is a data structure that stores keys and values. (5468.140197753906):  And those are technical terms, keys and values. (5470.420166015625):  The analog in the human world would be like literally a dictionary (5474.3001708984375):  that you'd have in a classroom, like a dictionary with words and definitions, (5478.460205078125):  more generally known as keys and values. (5481.380187988281):  So that's all a dictionary is. (5483.100158691406):  It associates keys with values. (5485.500183105469):  So for instance, you could think of it almost (5487.500183105469):  as like two columns in a spreadsheet, where on the left, you put the key. (5490.740173339844):  On the right, you put the value. (5492.0802001953125):  Or specifically, you put the word in a dictionary and the definition (5495.220153808594):  thereafter. (5495.720153808594):  And that's roughly how the printed pages in a dictionary are laid out. (5499.480163574219):  So dictionaries associate words with definitions, (5502.5802001953125):  more generally, keys with values. (5504.980163574219):  But it's an abstract data type in that we could implement this (5507.5401611328125):  in a bunch of ways. (5508.380187988281):  We could use maybe two arrays, one array for the keys, (5511.500183105469):  one array for the definitions. (5512.900207519531):  And you just kind of hope that they line up. (5515.0601806640625):  Bracket i in this one is the maps to bracket i in this one. (5518.3402099609375):  But an array is not going to give us the dynamism that we want, right? (5521.620178222656):  You might run out of space when Merriam-Webster or whoever (5525.620178222656):  adds new words to the English language. (5527.5401611328125):  You might not want to be using an array. (5529.260192871094):  You might want to use a linked list. (5530.720153808594):  But again, linked lists kind of then devolve into big O of N. (5533.400207519531):  And that's not good for dictionaries and spell checking. (5536.2801513671875):  If you have to check every possible word to find something, (5539.240173339844):  getting something that's a little faster than that is compelling. (5542.000183105469):  So let's consider how maybe Apple, maybe Google, maybe others (5545.360168457031):  are actually implementing contacts. (5547.960205078125):  Because even though I implied in week 0, and maybe outright said, (5552.0802001953125):  it's an array, it's a big list of all of your names of contacts, (5556.480163574219):  maybe of some fixed size, they probably better (5559.120178222656):  be using some variant of a linked list. (5562.440185546875):  Otherwise, you could never add more friends, potentially. (5565.000183105469):  You'd max out. (5565.600158691406):  And they'd say, you have to unfriend someone just to fit it. (5567.8402099609375):  As an aside, this is sort of true in the social media world. (5570.520202636719):  Like once you have like 5,000 friends on Facebook, you can't have 5,001. (5573.8001708984375):  Once you have some number on LinkedIn, you can't have more connections. (5576.8001708984375):  That's not necessarily that they're using arrays. (5578.8402099609375):  But it is the same implication that they've (5580.8402099609375):  chosen some finite size for memory. (5583.640197753906):  So how might we consider implementing a dictionary specifically (5587.2001953125):  for your address book or your contacts so you (5589.360168457031):  can store the names of everyone, ideally alphabetically, (5591.960205078125):  but also their phone numbers and maybe anything else? (5595.000183105469):  Well, ultimately, we want to be able to get at someone's name (5597.5601806640625):  and lead to their number. (5599.2801513671875):  So the keys and values for our discussion (5601.2001953125):  here will be names are the keys and phone numbers are the values. (5604.760192871094):  But the values themselves could also include email address and mailing (5608.440185546875):  address and all of that. (5609.600158691406):  But we'll keep it simple, names and phone numbers. (5612.2001953125):  So here's how you might think about this or draw it on a chalkboard, (5615.16015625):  two columns, or in a spreadsheet, left and right. (5617.720153808594):  But how could we actually implement this in memory? (5620.000183105469):  Because ideally, we don't want it to devolve into something linear. (5623.440185546875):  We don't want to have to look through all of my friends and family (5626.240173339844):  and colleagues to find someone whose name starts with Z, for instance, (5629.360168457031):  or anything else. (5630.600158691406):  It would be nice to have something logarithmic with binary search. (5634.600158691406):  But with binary search, again, we have to maybe use a tree instead. (5641.0401611328125):  But now we have to use two pointers instead of one. (5643.480163574219):  There's a lot of trade-offs here. (5645.18017578125):  Let's see how else we could solve this same problem. (5647.920166015625):  Because wouldn't it be nice, and we've not really talked about this before, (5651.2001953125):  if we instead aspire to this sort of holy grail of algorithms? (5654.600158691406):  Like, the best algorithm out there is surely one that's big O of 1, (5658.720153808594):  like constant time. (5660.240173339844):  Because what that means is it doesn't matter if you (5662.360168457031):  have one friend, 10 friends, 100, 1,000, a million, a billion friends. (5665.720153808594):  Doesn't matter how big n is. (5667.400207519531):  Your searches will always take you the same amount of time. (5671.2801513671875):  It is independent of n. (5673.120178222656):  And that's why it's sort of the ultimate goal for performance. (5677.960205078125):  So can we get to this aspiration? (5681.0401611328125):  Well, a couple of building blocks. (5682.640197753906):  There's this notion in computing known as hashing. (5685.2801513671875):  And hashing is a technique, literally a function in math or in code, (5689.2001953125):  that actually takes any number of inputs and maps them (5693.240173339844):  to a finite number of outputs. (5695.16015625):  So if you think back to high school math, domains and ranges, (5698.2801513671875):  you can take an infinite domain with any values in the world, (5701.2801513671875):  but it reduces them, a hash function, to a finite range of specific values. (5705.520202636719):  So for instance, it's no accident that we have these four buckets (5708.3201904296875):  on the stage now, each of which has a suit from a deck of cards. (5712.640197753906):  We got, for visibility's sake, the biggest cards we can. (5715.120178222656):  These are the super jumbo playing cards. (5717.0401611328125):  And in this box are a bunch of randomly ordered playing cards. (5720.480163574219):  And typically, if you were to ever play some game (5722.8201904296875):  or you wanted to sort these for some reason, (5724.720153808594):  how would you go about sorting them by suit and also by number? (5728.600158691406):  Odds are, if you're like me, you'd probably kind of take some shortcuts (5731.720153808594):  and maybe pull out all of the hearts, pull out all of the spades, (5734.960205078125):  pull out all of the clubs, or you'd kind of bucketize it into categories. (5738.8001708984375):  And that term is actually technical. (5740.5401611328125):  Here are four buckets, to make this clear. (5742.960205078125):  And for instance, if the first card I find is like the five of hearts, (5746.0802001953125):  you know what, just to kind of make my life easier, (5747.920166015625):  I'm going to put that into the hearts bucket. (5749.8001708984375):  Or here we have four. (5750.8001708984375):  Here we have five. (5752.68017578125):  Here we have six. (5754.68017578125):  Here we have queen. (5756.8402099609375):  And notice that I'm putting these cards into the appropriate buckets. (5760.2801513671875):  Why? (5761.0001220703125):  Because ultimately, then I'm going to have four problems, but of smaller size. (5764.72021484375):  A 13 size problem, 13, 13, 13, and frankly, (5767.960205078125):  it's just going to be easier cognitively, dare say algorithmically, (5771.0802001953125):  to then sort each of the 13 cards in these buckets (5774.240234375):  rather than deal with like four suits somehow combined all together. (5777.64013671875):  So if you've ever in life made piles, if you've ever literally used buckets (5780.8001708984375):  like this, you are hashing. (5783.0401611328125):  I'm taking some number of inputs, 52 in this case, (5785.920166015625):  and I'm mapping it to a finite number of outputs, four in this case. (5790.3602294921875):  So hashing, again, just takes in inputs and hashes them (5794.3602294921875):  to output values in this way. (5796.5201416015625):  So beyond that terminology, let's consider (5798.5601806640625):  what we can now do with hash functions that's (5801.16015625):  a little more germane to storing things like our friends and family (5804.18017578125):  and colleagues in dictionaries. (5807.0001220703125):  A hash function is just one that does that. (5809.2801513671875):  I, as the human, was just implementing or behaving like a hash function. (5812.880126953125):  But technically, a hash function is actually a math function or a function (5816.400146484375):  in C or Scratch or soon Python or other languages (5819.920166015625):  that takes as input some value, be it a physical card or a name (5824.16015625):  or a number or something else, and outputs some value. (5827.400146484375):  And we can use hashing as an operation to implement what we'll call hash tables. (5833.8001708984375):  And that's kind of what that dictionary was. (5835.8001708984375):  If you think about how I drew it on the screen as two columns, (5838.380126953125):  it's like a table of information, keys on the left, values on the right. (5842.0401611328125):  So what is a hash table? (5843.72021484375):  The simplest way to think about it is that this (5845.8602294921875):  is an amalgam of a combination of arrays and linked lists, right? (5850.8001708984375):  We kind of borrowed some ideas of linked lists (5853.5201416015625):  a moment ago to give us trees in two dimensions. (5856.16015625):  What if we stick with this idea of having two-dimensional world, (5859.3201904296875):  but now use an array initially? (5861.8001708984375):  So we get the speed benefits of arrays, because everything's contiguous. (5864.8001708984375):  We can do simple arithmetic and jump to the middle or the middle or the middle (5867.920166015625):  or the first or the last very easily. (5869.8001708984375):  And then you know what? (5870.8001708984375):  Let's kind of use the horizontal part of the screen (5873.0001220703125):  to give us linked lists as needed. (5875.1202392578125):  So for instance, if the goal at hand is to implement the contacts in my cell (5878.72021484375):  phone or my Mac or PC, let me propose that we start, at least in English, (5884.240234375):  with an array of size 26. (5886.2001953125):  Of course, it's zero index, so it's really location 0 through 25. (5889.740234375):  And for the sake of discussion, let me propose (5891.6202392578125):  that location 0 represents A, location 25 represents Z, (5895.5201416015625):  and then everything else in between. (5897.7601318359375):  We know from C that we can convert, thanks to ASCII and Unicode, (5900.880126953125):  from letters to numbers and back and forth. (5903.3201904296875):  So in constant time, we can find location A. (5906.240234375):  In constant time, we can find location Z. (5908.5601806640625):  Why? (5909.3602294921875):  Because we're using an array, just like in. (5912.920166015625):  Week 2. (5914.00016605854):  All right. (5914.600165963173):  Well, suppose that I want to think about these more (5916.720165967941):  as letters of the alphabet, the English alphabet, rather than numbers. (5920.040165901184):  So it's equivalent to label them A through Z. (5922.560166358948):  And suppose now I want to start adding friends and family (5925.200165748596):  and contacts to my address book. (5927.280165672302):  How might this look? (5928.480166435242):  Well, if the first one I want to add is Mario, Mario's name starts with an M. (5932.240165710449):  And so that's, you know, A, B, C, D, E, F, G. (5934.320165634155):  OK, M goes there. (5936.000165939331):  So I'm going to put Mario at that location in the array. (5940.960166931152):  After that, I add a second person. (5942.440166473389):  For instance, how about Luigi? (5943.920166015625):  Well, L comes just before M. So it stands to reason (5946.320167541504):  that it goes there in the array. (5948.80016708374):  Meanwhile, if I go and add another character like Peach, (5951.520164489746):  she's going to go there a few spots away because her name starts with P. (5955.960166931152):  Meanwhile, here's a whole bunch of other Nintendo characters (5958.740165710449):  that happen to have unique letters of their first names. (5962.560165405273):  And there's room for everyone, room for everyone (5965.00016784668):  on the board A through Z with some blanks in the middle. (5967.600166320801):  But you can perhaps see where this is going. (5969.440166473389):  When and where might a problem arise with this array-based approach? (5974.080165863037):  Yeah, so when we add someone else whose name collides (5978.1601638793945):  with one of these existing characters just because by accident (5981.600166320801):  they have a name that starts with the same letter. (5983.6801681518555):  So for instance, there's Lakitu here, who collides with Luigi potentially. (5988.080169677734):  Here's Link, who collides with both of them. (5990.84016418457):  But I've drawn a solution to this along the way. (5993.440162658691):  I could, if I was Decronian, just remove Luigi from the data structure (5997.440162658691):  and put Lakitu in, or remove and then put Link in there instead. (6000.440162658691):  But that's kind of stupid. (6001.560165405273):  If you can only have one friend whose name starts with L, (6004.360168457031):  that's just bad design. (6006.320167541504):  But what if we now, in the off chance I have (6009.960166931152):  two friends whose names start with the same letter, (6012.760162353516):  well, I'll just kind of string them together, link them together, (6016.260162353516):  no pun intended, using pointers of sorts. (6018.920166015625):  So my vertical here is an array. (6021.020164489746):  And this is just an artist's rendition. (6022.600166320801):  There's no actual notion of up, down, left, right in the computer's memory. (6025.760162353516):  So this is my array, always of size 26. (6028.560165405273):  And each of the elements in this array are now not a simple number, (6032.6801681518555):  but it's a pointer to a linked list. (6035.400169372559):  And if there's nothing there, it's just null, null, null, null. (6038.920166015625):  But otherwise, it's a valid address that points to the first node. (6042.280166625977):  And you know what? (6043.080169677734):  If we have multiple names with the same letters, (6045.0401611328125):  we can just string these nodes together together using pointers as well. (6050.360168457031):  So a hash table then, as implemented here, is an array of linked lists. (6055.740173339844):  And that allows us to, one, get some speed benefit, (6058.50016784668):  because look how fast we inserted or found Mario, Luigi, and Peach. (6061.900161743164):  But it still covers the scenario where, OK, some people (6065.260162353516):  can have the same first letters. (6066.5401611328125):  Some of these names will collide. (6068.860168457031):  So collisions are an expected problem with a hash table (6072.180160522461):  whereby two values from some domain happen to map to the same value. (6078.200164794922):  And frankly, you'll see this here too. (6079.740173339844):  So these buckets are technically a finite size. (6082.100158691406):  They're definitely big enough for 13 cards each. (6084.740173339844):  But you could imagine a world where, if I'm using two decks, three decks, (6088.100158691406):  or four decks, I'm going to run out of space. (6089.980163574219):  And then my data structure can't fit any more information. (6092.580169677734):  But we're not going to have this problem here, (6094.50016784668):  because the linked lists, as we've seen, can grow and even shrink (6097.260162353516):  as much as they want. (6098.180160522461):  In the world of Nintendo, there's actually lots of collisions. (6100.720169067383):  And these aren't even all of the characters. (6103.560165405273):  So that's then a hash table. (6105.460159301758):  So with a hash table in mind, how fast is it? (6109.3001708984375):  Did we achieve that holy grail of constant time? (6112.50016784668):  Well, for some of these names, if I back up, yeah, it's kind of constant time. (6116.220169067383):  Like Yoshi and Zelda, boom, constant time. (6118.420166015625):  Location 24, location 25. (6120.5401611328125):  Some of them, though, like Luigi's Lucky Chute link, (6123.460159301758):  it's not quite constant time, because I first (6126.020172119141):  have to get to Luigi's location. (6127.700164794922):  And then I have to follow this linked list. (6129.900161743164):  So technically then, what's the running time of searching a hash table? (6136.100158691406):  Sometimes you'll get lucky, but sometimes you won't. (6139.5401611328125):  Consider the worst case. (6140.900161743164):  Big O is often used to describe worst case. (6142.980163574219):  So what would be the worst case in your own contacts? (6146.140167236328):  Little letter? (6147.980163574219):  So N, why? (6150.900161743164):  Correct. (6151.380172729492):  And so to summarize, like in some weird scenario, (6153.50016784668):  like all of your friends and family and contacts (6155.940170288086):  could have names that start with the same letter. (6158.100158691406):  And then it doesn't matter that this is a hash table (6160.780166625977):  with an array of linked lists. (6162.700164794922):  For all intents and purposes, if your friends' names only (6165.620162963867):  start with the same letter, all you have is a linked list. (6168.50016784668):  And much like with a tree, if you don't keep it balanced, (6171.580169677734):  all you have really is a linked list. (6173.700164794922):  So technically speaking, yes, hash tables are big O of N, (6178.340179443359):  even though, even if you're good about, even if you have friends, (6184.5401611328125):  in the worst case, hash tables are big O of N. (6186.66015625):  Why? (6186.980163574219):  Because it can devolve into this perverse scenario (6189.100158691406):  where you just have lots and lots of collisions all at the same values. (6192.340179443359):  But there's got to be a way to fix this, right? (6194.640167236328):  How could we chip away at the length of these chains, so to speak? (6198.420166015625):  Could I decrease the length of these linked lists (6200.5401611328125):  so that with much higher probability, there's no collisions? (6203.3001708984375):  Well, maybe the problem is that I started with just 26 buckets. (6207.100158691406):  I mean, four buckets here, 26 here. (6209.0601806640625):  Maybe the problem is the size of my array. (6210.820159912109):  So what if I instead just give myself a bigger array? (6213.220153808594):  And it's too big to fit on the screen. (6214.7801513671875):  But what if I instead have a bucket for names (6216.68017578125):  that start with L-A-A and L-A-B and L-A-C, L-A-D, dot, dot, dot, (6221.860168457031):  all the way down? (6222.5401611328125):  Now, when I hash these names into my hash table, (6228.18017578125):  Locky2 is going to end up at their own location here, (6230.7801513671875):  Link at their own location here, Luigi at their own location here. (6234.3001708984375):  And so now I don't have linked lists. (6236.980163574219):  I really just have an array of names. (6239.580169677734):  So now I'm actually back to constant time. (6242.3001708984375):  Why? (6242.940155029297):  Because so long as every letter of the alphabet has an ASCII value, (6247.020172119141):  I can get that in constant time. (6248.420166015625):  And we did that as far back as week one. (6250.580169677734):  And so I can figure out what the arithmetic location is of each (6254.900177001953):  of these buckets just by looking at one, two, three characters, (6257.820159912109):  or the total number of letters that I care about, (6260.620178222656):  which is just three in this case. (6262.18017578125):  So this feels like a solution, even though I (6264.020172119141):  haven't drawn all the names. (6265.460174560547):  It feels like we've solved the problem. (6267.18017578125):  But what's the downside or trade-off of what we've just done? (6272.380157470703):  Sorry? (6273.980163574219):  Memory. (6274.580169677734):  So not pictured here is the dot, dot, dot and everything (6277.740173339844):  above and everything below. (6279.260162353516):  This just exploded in terms of the number of locations in this array. (6284.020172119141):  Why? (6284.66015625):  Because if I'm taking into account not just the first letter, (6287.260162353516):  but the first, the second, and third, that's 26 to the third power. (6291.140167236328):  26 times 26 times 26. (6293.740173339844):  And even though there's going to be a crazy number of names that just (6297.340179443359):  don't exist, I can't think of a Nintendo character whose name starts with L-A-A. (6301.900177001953):  You still need that bucket. (6303.260162353516):  Why? (6303.900177001953):  Because otherwise you don't have contiguousness. (6306.020172119141):  You can't just arbitrarily label these buckets. (6308.460174560547):  If you want to be able to use a function that (6310.580169677734):  looks at first, second, third letter and then arithmetically figures out (6314.020172119141):  where to go, whether it's 0 to 25 or 0 to 26 to the third power minus 1, (6319.500152587891):  being the number of buckets there. (6321.260162353516):  So there's a trade-off there. (6322.460174560547):  You're wasting a huge amount of memory just to give yourself that time. (6326.3001708984375):  But that would then give us constant time. (6328.980163574219):  So in that sense, if we have an ideal hash function whereby the function (6333.0601806640625):  ensures that no values collide, we do actually (6336.900177001953):  obtain that holy grail of big O of 1. (6339.860168457031):  Because it only takes one or maybe three steps to find that name's location. (6345.100158691406):  Now to make this clear, how do we translate this to something like code? (6348.020172119141):  Well, here again is the struct we used last time for that of a person. (6351.260162353516):  And a person had a name and a number. (6353.18017578125):  Here, for a hash table, we might do something a little bit differently. (6356.900177001953):  We might now have a node in a hash table storing (6360.700164794922):  the person's name, person's phone number, and a pointer (6364.66015625):  to the next such person in that chain, if needed. (6368.3001708984375):  Hopefully, this is going to be null most of the time, all of the time. (6371.020172119141):  But we need it just in case we do have that collision. (6373.380157470703):  We've seen in our pictures the names, like Mario, Luigi, and so forth. (6376.620178222656):  We didn't see the numbers. (6377.740173339844):  But that's what's inside of those boxes on the picture. (6380.18017578125):  But that kind of node would give us what we need to build up these linked lists. (6384.500152587891):  Meanwhile, what is the hash table itself, that vertical strip along the left? (6388.500152587891):  Well, it's really just a variable. (6390.460174560547):  We could call it table for short, of size 26. (6393.66015625):  And each of the locations in that array that was on the side here, (6397.140167236328):  at least in the simple, small version, was a pointer to a node. (6401.000152587891):  So it's null if there's no one there. (6403.380157470703):  Or it's a valid address of the first node in the linked list. (6407.860168457031):  So this, then, is a hash table. (6409.66015625):  And each of those nodes, to be clear, would be defined as follows. (6413.5401611328125):  So what's the takeaway, then, with a hash table? (6415.5401611328125):  Ideally, with a good hash function and with a good set of inputs, (6419.66015625):  where you're not presented with some perverse set of inputs that's (6422.5401611328125):  all the friends whose names start with the same letter, (6425.66015625):  ideally, what the hash function will be doing for you is this. (6428.7801513671875):  The input is going to be someone's name. (6430.580139160156):  The algorithm in the middle is going to be the hash function. (6433.080139160156):  And the output is the so-called hash value, or location in this case. (6436.940185546875):  So for instance, in the case of Mario, when we had just 26 buckets total, (6442.3001708984375):  the input to the hash function would be Mario. (6444.580139160156):  That hash function would really just look at the first letter, M, (6447.580139160156):  in that case, and would ideally output the number 12. (6450.5201416015625):  I did the same thing, but in my head, whenever I pulled out a card, (6453.440185546875):  like the five of diamonds here, I figured out, OK, (6455.840148925781):  that's location 0 out of my 0, 1, 2, 3, or 4 total buckets. (6461.080139160156):  Here, we're doing it instead alphabetically. (6463.000183105469):  And so someone like Luigi, meanwhile, would have a hash value of 11. (6467.3201904296875):  These numbers would be bigger, of course, (6469.2001953125):  though, if we're looking at 1, 2, 3 letters instead of just 1. (6474.16015625):  So with that said, if we were to implement this in actual code, (6479.16015625):  a hash function, I did it sort of physically by acting out the cards. (6483.360168457031):  Here is how we might implement this in code using C. (6486.760192871094):  I could have a function called hash whose argument is a string, (6489.8001708984375):  a.k.a. char star, a name of which is word, where the word is (6493.840148925781):  like the first word in their name. (6496.2001953125):  We want this function to return an int, which ideally in this case of 26 (6499.920166015625):  buckets would be a number from 0 to 26. (6502.3001708984375):  And how do we achieve that? (6503.5201416015625):  Well, if we use our old friend C type, which (6505.400146484375):  had a function like to upper from a couple of weeks back, (6508.2801513671875):  we could pass in the first letter of that word, (6512.080139160156):  capitalize it, which is going to give us a number that's 65, 66, 67 on up (6517.080139160156):  for the 26 English letters. (6518.840148925781):  And if I subtract 65, a.k.a. (6521.64013671875):  quote unquote a, single quotes because it's a char, (6524.120178222656):  that's going to mathematically give me a number between 0 and 25 inclusive. (6530.2001953125):  There is a potential bug if I pass in punctuation or anything that's (6534.080139160156):  not alphabetical. (6535.0401611328125):  Like bad things will happen, so I should probably (6537.120178222656):  have some more error checking. (6538.480163574219):  But this is the simplest way in code that I (6540.760192871094):  could implement a hash function that looks only (6543.000183105469):  at the first letter of their name. (6544.400146484375):  Probably not ideal because I can think of friends in the real world who (6547.400146484375):  have the same first letter of their name. (6549.16015625):  Whether this is better or worse than looking (6551.080139160156):  at two letters, three letters, four letters, (6553.080139160156):  it's going to depend on how much memory you want to spend (6555.440185546875):  and how much time you want to ultimately save. (6557.880187988281):  Let me tweak this, though, a little bit. (6559.880187988281):  It's conventional in C, just so you know, (6562.16015625):  that if you're passing in a string that is a char star to a function (6566.000183105469):  and you have no intention of letting that function change the string, (6569.720153808594):  you should probably declare the argument to the function as const. (6573.16015625):  And that will tell the compiler to please (6575.600158691406):  don't let the human programmer actually change (6578.440185546875):  that actual word in this function. (6580.0401611328125):  It's just not their place to do so. (6581.880187988281):  And we can actually do something else. (6583.460144042969):  In a hash function, because you're using, in this case, the output, (6586.960144042969):  the integer, as a location in an array, it had better not be negative, right? (6591.240173339844):  You want it to be 0 or positive. (6593.840148925781):  And so technically, if you want to impose that in code, (6596.600158691406):  you can specify that the int that's being returned has to be unsigned. (6600.68017578125):  That is, it's 0 on up through the positive numbers. (6603.600158691406):  It is not a negative value. (6605.440185546875):  So this is slightly better than the previous version (6607.840148925781):  where we didn't have these defenses in place. (6611.760192871094):  All right, so what does this actually mean? (6614.360168457031):  In practice, you don't get to necessarily pick the hash function (6619.2001953125):  based on the names of your friends, right? (6620.880187988281):  Presumably, Apple and Google and others already (6623.120178222656):  chose their hash function independent of what your friends' names are. (6626.8001708984375):  So ideally, they want to pick a hash function that generally is quite fast, (6630.920166015625):  big O of 1. (6632.0401611328125):  But practically speaking, in a hash table, (6634.720153808594):  unless you get really lucky with the inputs, which you generally won't, (6638.960144042969):  really it's big O of n running time. (6641.360168457031):  Why? (6641.840148925781):  Because in the worst possible scenario, you might have one long linked list. (6645.5601806640625):  But in practice, ideally, and this is a little naive, (6648.920166015625):  but suppose that you have a uniform distribution of friends in the world (6651.880187988281):  where 126 of them have names starting with A and then another 126 out of B (6658.480163574219):  and then dot, dot, dot, Z. That would be a nice uniform distribution (6661.480163574219):  of friends. (6662.240173339844):  Technically then, your running time of a hash table for searching it (6666.240173339844):  or deleting or inserting would technically (6668.360168457031):  be big O of n divided by k, where k is the number of buckets, a constant. (6672.68017578125):  So it's technically big O of n divided by 26. (6675.920166015625):  Now again, per our discussion of big O notation, that's still the same thing. (6680.5201416015625):  You get rid of constant factors. (6682.000183105469):  So yes, it's 26 times faster. (6684.3201904296875):  The chains are 126 the length. (6686.960144042969):  But asymptotically, in terms of big O notation, it's still big O of n. (6691.380187988281):  And here's where now we can start to veer away (6693.720153808594):  from what is theoretically right versus what is practically right. (6698.0401611328125):  In reality, in the real world, if you work for Google, Microsoft, Apple, (6701.400146484375):  and others, 26 times faster is actually faster in the real world, (6706.080139160156):  even though a mathematician might say, ah, that's really the same thing. (6709.3201904296875):  But it's not. (6710.080139160156):  Like the real world wall clock time, if you (6712.440185546875):  watch the number of seconds passing on the clock, (6714.760192871094):  n over k is a much better running time than big O of n. (6718.8001708984375):  So here, too, we're getting to the point where the conversations need (6721.5601806640625):  to become a little more sophisticated. (6724.16015625):  It's not quite as simple as theory versus practice. (6726.760192871094):  It depends on what matters ultimately to you. (6729.880187988281):  But ideally, and literally, if somehow or other they (6733.400146484375):  picked an ideal hash function, big O of 1 would really be the ideal here, (6738.080139160156):  would really be the running time we achieve. (6740.000183105469):  And what you'll generally find in the real world (6742.0401611328125):  is that you don't use hash functions that are as simplistic (6744.480163574219):  as just look at the first letter. (6746.000183105469):  And honestly, they won't generally look at the first (6747.920166015625):  and the second and third letter. (6749.260192871094):  They'll use some even fancier math to put real downward pressure (6752.5201416015625):  on the probability of collisions so that, yes, they will still happen. (6756.16015625):  But most of the time, a really good hash function, (6759.0401611328125):  even if it's not quite ideal, will be darn close to constant time, (6763.5201416015625):  which makes hash tables and, in turn, dictionaries (6766.16015625):  one of the most universally compelling data structures to use. (6770.2001953125):  Now, with that said, we have time for just another data structure or so. (6773.600158691406):  And this is not a typo. (6774.5601806640625):  This one's called a trie. (6776.3201904296875):  And a trie is short for retrieval, which is weird because you say retrieval, (6779.760192871094):  but we say trie. (6780.8001708984375):  But that's the etymology of trie. (6782.3201904296875):  And a trie is sort of the weirdest amalgamation of all of these things (6786.64013671875):  whereby a trie is a tree of arrays. (6790.68017578125):  So a hash table is an array of linked lists. (6794.840148925781):  A trie is a tree of arrays. (6798.360168457031):  So at some point, computer scientists just (6800.080139160156):  started mashing together all of these different inputs. (6802.5201416015625):  And let's see what comes out of it. (6803.960144042969):  But a trie is actually really interesting. (6806.120178222656):  And what you're about to see is a data structure (6808.120178222656):  that is literally big O of one time, constant time. (6813.000183105469):  But there is a downside. (6814.64013671875):  So in a trie, every node is an array. (6818.960144042969):  And every location in that array generally (6821.360168457031):  represents a letter of the alphabet. (6823.16015625):  But you could generalize this away from words, too. (6825.400146484375):  But a trie, in this case, if we have a root node, (6829.000183105469):  that root node is technically a big array with 26 locations. (6832.68017578125):  And if you want to insert names or words more generally into a trie, (6837.0401611328125):  what you do is this. (6838.480163574219):  You hash again and again and again, creating one array (6842.880187988281):  for every letter in your word. (6844.68017578125):  So what do I mean by that? (6845.920166015625):  If we've got 26 elements here, this would be representing A. (6849.760192871094):  This would be representing Z. And initially, these are all null by default (6853.3201904296875):  when you have just this root. (6854.68017578125):  But suppose I want to insert a few friends of mine, including Toad, (6858.240173339844):  for instance. (6858.760192871094):  T-O-A-D is the name. (6860.8001708984375):  So how would I do that? (6862.3201904296875):  I would first find the location for T based on its number, 0 through 25. (6867.0401611328125):  And if this is T, what would I then do? (6869.0401611328125):  I would change the null to actually be a pointer to another node, (6872.720153808594):  a.k.a. another array. (6874.5201416015625):  And then I would go into this second array (6876.720153808594):  and hash on the second letter of Toad's name, which is, of course, O. (6880.2801513671875):  And then I would set a pointer to a third node in my trie, (6884.000183105469):  which would be represented here. (6886.120178222656):  So another 26 pointers. (6889.16015625):  Then I would find the pointer representing A. (6891.480163574219):  And I would create, finally, a fourth node, another array, (6894.880187988281):  representing the fourth letter of Toad's name. (6898.360168457031):  But because Toad's name ends with D, and therefore I already (6903.360168457031):  have four nodes here, we need to specially color, (6907.720153808594):  though we could probably use an actual variable here, (6910.760192871094):  I need to somehow indicate that Toad's name stops here. (6914.080139160156):  So it's not null per se. (6915.840148925781):  This actually means that T-O-A-D is in this data structure. (6918.840148925781):  But I did this deliberately because another friend of mine (6921.240173339844):  might be Toadette in the Nintendo world. (6922.920166015625):  And Toadette, of course, is a super string of Toad. (6926.0401611328125):  That is, it's longer, but it shares a common prefix. (6928.64013671875):  So Toadette could continue. (6929.920166015625):  And I could have another node for the E, another node for the T, (6932.68017578125):  another node for the second T, and another node for the last E. (6935.720153808594):  But I somehow have to mark that E is the end of her name as well. (6940.5601806640625):  So even though they share a common prefix, (6943.2401123046875):  the fact that there's two green boxes on the screen (6945.5201416015625):  means that T-O-A-D is in this dictionary as a key, (6949.7601318359375):  as is T-O-A-D-E-T-T-E is another key. (6953.480224609375):  And technically speaking, what's in these boxes, (6955.480224609375):  too, it's not just a pointer. (6956.8402099609375):  It's probably Toad and Toadette's phone number and email address (6959.920166015625):  and the actual value of the dictionary. (6962.8001708984375):  Which is to say this, too, is in fact a dictionary. (6965.72021484375):  A dictionary is just an abstract data type, a collection of key value pairs, (6969.16015625):  just like I claimed a stack and a queue was. (6971.360107421875):  And how you implement it can differ. (6973.16015625):  You could implement it with a hash table, an array of linked lists, (6975.960205078125):  as we just did. (6977.1201171875):  Or you can implement a dictionary as a tri, a tree of arrays. (6982.2401123046875):  And let me add one more name to the mix. (6984.8001708984375):  Tom, for instance, a valid name from the universe. (6987.3201904296875):  T-O-M just means that, OK, that name exists in this structure as well. (6993.0001220703125):  Now, what is the implication of storing the names in this way, (6997.400146484375):  which is sort of implicitly? (6999.0802001953125):  Like, I'm effectively storing Toad and Toadette and Tom in this data (7004.68017578125):  structure without actually storing T or O or A or D or any of the other letters. (7010.480224609375):  I'm just implicitly storing those letters (7012.7601318359375):  by actually using valid pointers that lead to another node. (7016.440185546875):  And so what's the implication of this in code? (7018.7601318359375):  Well, in code, it might look like this. (7020.880126953125):  Every node in a tri is now redefined as being an array of size 26. (7027.0001220703125):  And I'll call it children, just to borrow the family tree metaphor. (7030.1002197265625):  And that in each of these nodes, there is room for the person's phone number, (7034.2601318359375):  for instance, a.k.a. (7035.16015625):  a string or char star. (7037.0802001953125):  So what does this mean? (7038.2401123046875):  Well, if there's actually a non-null number there, (7041.0401611328125):  that's equivalent to there being a green box. (7042.920166015625):  Like, if you actually see plus 1, 617 dash whatever there, (7046.1201171875):  that means there's a green box because Toad's number is right here (7049.16015625):  or Toadette's number is down here or Tom's is over there. (7052.3201904296875):  But if this is null, that just means that maybe this (7054.480224609375):  is the T or the O or the E, which are not actually ends of people's names. (7060.360107421875):  So that's all these nodes actually are. (7062.8402099609375):  And if we think back now to what this data structure looks like, (7066.5201416015625):  this is, in fact, a data structure that can be navigated in constant time. (7071.920166015625):  Why? (7072.440185546875):  Well, all we need to keep track of this data structure (7074.7401123046875):  is literally one pointer called tri that's (7077.0802001953125):  a pointer to the first of these nodes, the so-called root of the tri. (7080.2401123046875):  And when it comes to now thinking about the running time of a tri, (7083.8402099609375):  well, what is it? (7084.880126953125):  Well, if you've got n friends in your contacts already, (7087.920166015625):  or if there's n keys in that data structure, how many steps (7092.5201416015625):  that take to find anyone? (7094.5201416015625):  Well, whether I have three names, Toad, Toadette, or Tom, (7097.320141792297):  or three million names in that data structure, (7099.320141792297):  how many steps will it take me to find Toad ever? (7102.840141296387):  T-O-A-D. How many steps for Toadette? (7105.440141677856):  T-O-A-D-E-T-T-E. Eight steps. (7108.600141525269):  How about for Tom? (7109.320140838623):  One, two, three. (7110.56014251709):  And frankly, I'm sure if we looked it up, (7112.400140762329):  there's probably a limit on the number of characters in a Nintendo character's (7116.200141906738):  name. (7116.720142364502):  Maybe it's 20 characters total, or maybe a little longer, 30. (7119.56014251709):  There's some fixed value. (7120.680141448975):  It's not unbounded. (7121.800142288208):  There's not an infinite number of letters in any Nintendo character's name. (7124.920143127441):  So there's some constant value. (7126.36014175415):  Call it K. So no matter whose name you're looking for, (7129.720142364502):  it's going to take you maximally K steps. (7131.480140686035):  But K is a constant. (7132.56014251709):  And we ever always said that big O of K is the same thing as big O of 1. (7137.640140533447):  So for all intents and purposes, even though we're taking a bit of liberty (7140.9601402282715):  here, searching a trie, inserting into a trie, deleting from a trie (7145.040142059326):  is constant time. (7146.640140533447):  Because if you have a million, a billion names in the dictionary (7149.840141296387):  already, it's going to take up a huge amount of space. (7152.320140838623):  But it does not affect how many steps it takes (7154.440139770508):  to find Toad, or Toadette, or Tom. (7158.200141906738):  That depends only on the length of their names, which effectively (7161.280143737793):  is a constant value. (7162.960144042969):  But there is a downside here, and it's kind of a big one. (7166.200141906738):  In practice, I dare say most computers, most systems (7169.4001388549805):  would actually use hash tables, not tries, to implement dictionaries, (7174.680145263672):  collections of key value pairs. (7176.360137939453):  What's the downside of this here data structure, might you think? (7181.600143432617):  And this is just a representative picture for Toad, Tom, and Toadette. (7186.360137939453):  All the space it takes up. (7187.6401443481445):  I mean, even for these three names, look at how many empty pointers there are. (7191.280143737793):  So they're null, to be sure, but there's like 25 unused spaces here, (7195.32014465332):  another 25 unused spaces here, 24 unused spaces here. (7198.720138549805):  And what's not pictured is if I've got more and more names, (7201.440139770508):  this thing's just going to blow up with more and more and more and more arrays, (7205.240142822266):  even though there's not going to be someone (7207.200141906738):  whose name starts with like L-A-A, or L-B-A, or L-B-B. (7211.360137939453):  There's going to be so many combinations of letters (7213.880142211914):  where it's just going to be null pointers instead. (7216.160140991211):  So it takes up a huge amount of space, but it does give us constant time. (7220.600143432617):  And that, then, is this here trade-off. (7223.120147705078):  So I would encourage you here on out, as we exit the world of C, (7226.48014831543):  and so much of today's code and the past several weeks' code (7229.420135498047):  will soon be reduced in a week's time to just one line of code, (7232.800140380859):  two lines of code, because Python and the authors of Python (7236.000137329102):  will have implemented all of this week's and last week's and prior week's (7239.240142822266):  ideas for us. (7240.5201416015625):  We'll be able to operate at a higher level of abstraction (7243.280136108398):  and just think about what problems we want to solve (7245.440139770508):  and how we want to do so algorithmically and with data structures. (7248.760147094727):  And data structures, in conclusion, are everywhere. (7252.160140991211):  Has anyone recognized this spot in Harvard Square? (7258.340148925781):  Anyone? (7258.840148925781):  What are we looking at? (7261.48014831543):  So this is Sweetgreen, a popular salad place. (7263.720138549805):  And this is actually a dictionary or really a hash table of sorts. (7268.280136108398):  Why? (7268.800140380859):  Well, if you buy a very expensive salad at Sweetgreen (7271.240142822266):  and they put it on the shelf for you, if you've ordered via the app (7274.080139160156):  or online in advance, and if I, for instance, were to order a salad, (7277.040145874023):  it would probably go under the D heading. (7278.780136108398):  If Carter were to order a salad, it would go under C, Julia under Y. (7282.440139770508):  And so they hash the salads based on your first name (7285.840148925781):  to a particular location on the shelf. (7287.460144042969):  Why is that a good thing? (7288.64013671875):  Well, if it were just one long shelf that wasn't even alphabetical, (7291.560134887695):  it would be big O of N for me to find my salad (7294.120147705078):  and for Carter and Julia to find theirs. (7295.960144042969):  Because they've got 26 letters here, it's big O of 1. (7298.840148925781):  It's one step for any of us to find our salads. (7301.48014831543):  Except, again, in perverse situations, where to might this system devolve? (7307.32014465332):  Like 12.30 PM in the afternoon, for instance. (7311.240142822266):  What could go wrong? (7312.240142822266):  A lot of people with names with the same first letter order a salad. (7314.780136108398):  Yeah, a lot of people with the same first letters of their names (7317.800140380859):  might order a salad. (7318.760147094727):  So there's lots of D, D, D, D, D. Where do we put the next person? (7322.040145874023):  OK, well, maybe we overflow to E. What if there's a lot of E people? (7324.920135498047):  It overflows to F. What if it overflows? (7326.600143432617):  Then we go to G. And it sort of devolves anyway (7328.960144042969):  into a linked list or really multiple arrays (7331.120147705078):  that you have to search in big O of N time. (7333.5201416015625):  I've even been to Sweetgreen at non-popular times. (7336.120147705078):  And sometimes the staff just don't even choose to use the dictionaries. (7339.000137329102):  They just put it what's closest to them. (7340.960144042969):  So you have to search the same thing anywhere. (7342.880142211914):  But you'll start to see, now that you've seen some of these building (7345.040145874023):  blocks, that data structures are everywhere, (7346.920135498047):  algorithms are everywhere. (7348.120147705078):  And among the goals of CS50 now are to harness these ideas most efficiently. (7352.200134277344):  So that's a wrap. (7352.960144042969):  We'll see you next time. 